

<!DOCTYPE html>
<html lang="en" color-mode=light>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Tree树 - XXDSHZJ</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="google" content="notranslate" />
  
  <meta name="description" content="树(Tree)Binary Search TreeBa...">
  <meta name="author" content="Mengyuan Chen">
  <link rel="icon" href="/images/icons/favicon-16x16.png" type="image/png" sizes="16x16">
  <link rel="icon" href="/images/icons/favicon-32x32.png" type="image/png" sizes="32x32">
  <link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png" sizes="180x180">
  <meta rel="mask-icon" href="/images/icons/stun-logo.svg" color="#333333">
  
    <meta rel="msapplication-TileImage" content="/images/icons/favicon-144x144.png">
    <meta rel="msapplication-TileColor" content="#000000">
  

  
<link rel="stylesheet" href="/css/style.css">


  
    
<link rel="stylesheet" href="//at.alicdn.com/t/font_1445822_r673sha78lq.css">

  

  
    
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css">

  

  
    
      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/xcode.min.css" name="highlight-style" mode="light">

      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/solarized-dark.min.css" name="highlight-style" mode="dark">

      
  

  <script>
    var CONFIG = window.CONFIG || {};
    var ZHAOO = window.ZHAOO || {};
    CONFIG = {
      isHome: false,
      fancybox: true,
      pjax: false,
      lazyload: {
        enable: true,
        only_post: 'false',
        loading: '[object Object]'
      },
      donate: {
        enable: true,
        alipay: 'https://sm.ms/image/Y6TiL7UgNHm2RSl',
        wechat: 'https://sm.ms/image/aklIG9KSHPFcV8n'
      },
      galleries: {
        enable: true
      },
      fab: {
        enable: true,
        always_show: false
      },
      carrier: {
        enable: true
      },
      daovoice: {
        enable: false
      },
      preview: {
        background: {
          default: '',
          api: ''
        },
        motto: {
          default: '我在开了灯的床头下，想问问自己的心啊。',
          typing: true,
          api: 'https://v2.jinrishici.com/one.json',
          data_contents: '["data","content"]'
        },
      },
      qrcode: {
        enable: true,
        type: 'url',
        image: 'https://pic.izhaoo.com/weapp-code.jpg',
      },
      toc: {
        enable: true
      },
      scrollbar: {
        type: 'default'
      },
      notification: {
        enable: false,
        delay: 4500,
        list: '',
        page_white_list: '',
        page_black_list: ''
      },
      search: {
        enable: true,
        path: '/search.xml'
      }
    }
  </script>

  

  

<meta name="generator" content="Hexo 5.4.0"></head>

<body class="lock-screen">
  <div class="loading"></div>
  
    


  <nav class="navbar">
    <div class="left">
      
        <i class="iconfont iconhome j-navbar-back-home"></i>
      
      
        <i class="iconfont iconqrcode j-navbar-qrcode"></i>
      
      
        <i class="iconfont iconmoono" id="color-toggle" color-toggle="light"></i>
      
      
        <i class="iconfont iconsearch j-navbar-search"></i>
      
    </div>
    <div class="center">Tree树</div>
    <div class="right">
      <i class="iconfont iconmenu j-navbar-menu"></i>
    </div>
    
      <div id="qrcode-navbar"></div>
    
  </nav>

  
  

<nav class="menu">
  <div class="menu-container">
    <div class="menu-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <ul class="menu-content"><li class="menu-item">
        <a href="/ " class="underline "> 首页</a>
      </li><li class="menu-item">
        <a href="/galleries/ " class="underline "> 相册</a>
      </li><li class="menu-item">
        <a href="/archives/ " class="underline "> 归档</a>
      </li><li class="menu-item">
        <a href="/tags/ " class="underline "> 标签</a>
      </li><li class="menu-item">
        <a href="/categories/ " class="underline "> 分类</a>
      </li><li class="menu-item">
        <a href="/about/ " class="underline "> 关于</a>
      </li></ul>
    
      <div class="menu-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Cure The World </p></div>
    
  </div>
</nav>
  <main id="main">
  <div class="article-wrap">
    <div class="row container">
      <div class="col-xl-3"></div>
      <div class="col-xl-6"><article class="article">
  <div class="wrap">
    <section class="head">
  <img   class="lazyload" data-original="/images/theme/%E5%8F%AF%E7%88%B1%E6%97%A0%E6%B3%95%E5%A4%8D%E5%88%B6/img-6.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  draggable="false">
  <div class="head-mask">
    <h1 class="head-title">Tree树</h1>
    <div class="head-info">
      <span class="post-info-item"><i class="iconfont iconcalendar"></i>July 28, 2021</span>
      
      <span class="post-info-item"><i class="iconfont iconfont-size"></i>78245</span>
    </div>
  </div>
</section>
    <section class="main">
      <section class="content">
        <h2 id="树-Tree"><a href="#树-Tree" class="headerlink" title="树(Tree)"></a>树(Tree)</h2><p>Binary Search Tree<br>Balanced Tree: 左子树和右子树的高度差值最多是1<br>traversal: pre_order, in_order, post_order, level order<br>用递归的思想考虑，如何用左子树的值和右子树的值得到最终的值<br>例如：find the max val of a tree<br>find the max val of root.left and find the max val of root.right<br>then return max(root.val, max_left, max_right)</p>
<h2 id="线段树segment-tree"><a href="#线段树segment-tree" class="headerlink" title="线段树segment tree"></a>线段树segment tree</h2><p>Discrete version of a Segment Tree:<br>A balanced binary tree. O(logn)height given n elements.<br>Each leaf node (segment) represents an element in the array. Each non leaf node covers the union of it’s children’s range.<br>Operations:</p>
<ul>
<li>build(start, end, vals)  -&gt;  O(n)</li>
<li>update(index, value)    -&gt; O(logn)</li>
<li>rangeQuery(start, end)    -&gt; O(logn + k)</li>
<li>where k is the number of reported segments</li>
</ul>
<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><h3 id="方法一：Prim算法"><a href="#方法一：Prim算法" class="headerlink" title="方法一：Prim算法"></a>方法一：Prim算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span></span>&#123;<br>	<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">4</span>;<br>	vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; edges&#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>&#125;,&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>&#125;&#125;;<br>	vector&lt;vector&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt;&gt; <span class="hljs-built_in">g</span>(n);<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; e : edges)&#123;<br>		g[e[<span class="hljs-number">0</span>]].<span class="hljs-built_in">emplace_back</span>(e[<span class="hljs-number">1</span>],e[<span class="hljs-number">2</span>]);<br>		g[e[<span class="hljs-number">1</span>]].<span class="hljs-built_in">emplace_back</span>(e[<span class="hljs-number">0</span>],e[<span class="hljs-number">2</span>]);<br>	&#125;<br>	priority_queue&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt; q;<br>	<span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">seen</span><span class="hljs-params">(n)</span></span>;<br>	q.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>	<span class="hljs-keyword">int</span> cost = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>		<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> w = -q.<span class="hljs-built_in">top</span>().first;<br>		<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> v = q.<span class="hljs-built_in">top</span>().second;<br>		q.<span class="hljs-built_in">pop</span>();<br>		<span class="hljs-keyword">if</span> (seen[v]++) <span class="hljs-keyword">continue</span>;<br>		cost = cost + w;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; e : g[v])&#123;<br>			<span class="hljs-keyword">if</span> (seen[e.first]) <span class="hljs-keyword">continue</span>;<br>			q.<span class="hljs-built_in">emplace</span>(-e.first, e.second);<br>		&#125;<br>	&#125;<br>	cout &lt;&lt; cost &lt;&lt; endl;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="方法二：Kruskal’s-Algorithm"><a href="#方法二：Kruskal’s-Algorithm" class="headerlink" title="方法二：Kruskal’s Algorithm"></a>方法二：Kruskal’s Algorithm</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span></span>&#123;<br>	<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">4</span>;<br>	vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; edges&#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>&#125;,&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>&#125;&#125;;<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; q;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; e : edges)<br>        q.<span class="hljs-built_in">push_back</span>(&#123;e[<span class="hljs-number">2</span>], e[<span class="hljs-number">0</span>], e[<span class="hljs-number">1</span>]&#125;);<br>    <span class="hljs-built_in">sort</span>(q.<span class="hljs-built_in">begin</span>(), q.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">parent</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-built_in">iota</span>(parent.<span class="hljs-built_in">begin</span>(), parent.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>    function&lt;<span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(<span class="hljs-keyword">int</span>)&gt; find = [&amp;](<span class="hljs-keyword">int</span> x)&#123;<br>        <span class="hljs-keyword">return</span> x == parent[x] ? x : parent[x] = <span class="hljs-built_in">find</span>(parent[parent[x]]);<br>    &#125;;<br><br>	<span class="hljs-keyword">int</span> cost = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; t : q)&#123;<br>        <span class="hljs-keyword">int</span> w = t[<span class="hljs-number">0</span>], u = t[<span class="hljs-number">1</span>], v = t[<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">int</span> ru = <span class="hljs-built_in">find</span>(u), rv = <span class="hljs-built_in">find</span>(v);<br>        <span class="hljs-keyword">if</span> (ru == rv) <span class="hljs-keyword">continue</span>;<br>        p[ru] = rv;<br>        cost = cost + w;<br>	&#125;<br>	cout &lt;&lt; cost &lt;&lt; endl;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="208-Implement-Trie-Prefix-Tree-实现Trie-前缀树"><a href="#208-Implement-Trie-Prefix-Tree-实现Trie-前缀树" class="headerlink" title="208. Implement Trie (Prefix Tree)(实现Trie(前缀树))"></a>208. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">Implement Trie (Prefix Tree)(实现Trie(前缀树))</a></h2><p>Trie，又称前缀树或字典树，是一棵有根树，其每个节点包含以下字段：<br>指向子节点的指针数组children。对于本题而言，数组长度为26，即小写英文字母的数量。此时children[0] 对应小写字母a， children[1]对应小写字母b，…，children[25]对应小写字母z。<br>布尔字段isEnd，表示该节点是否为字符串的结尾。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>	vector&lt;Trie*&gt; children;<br>	<span class="hljs-keyword">bool</span> isEnd;<br>	<br>	<span class="hljs-function">Trie* <span class="hljs-title">searchPrefix</span><span class="hljs-params">(string prefix)</span> </span>&#123;<br>		Trie* node = <span class="hljs-keyword">this</span>;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> ch : prefix) &#123;<br>			ch -= <span class="hljs-string">&#x27;a&#x27;</span>;<br>			<span class="hljs-keyword">if</span> (node-&gt;children[ch] == <span class="hljs-literal">nullptr</span>) &#123;<br>				<span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>			&#125;<br>			node = node-&gt;children[ch];<br>		&#125;<br>		<span class="hljs-keyword">return</span> node;<br>	&#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-built_in">Trie</span>(): <span class="hljs-built_in">children</span>(<span class="hljs-number">26</span>), <span class="hljs-built_in">isEnd</span>(<span class="hljs-literal">false</span>) &#123;&#125;<br>    <br>    <span class="hljs-comment">/** Inserts a word into the trie. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string word)</span> </span>&#123;<br>		Trie* node = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> ch : word) &#123;<br>            ch -= <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (node-&gt;children[ch] == <span class="hljs-literal">nullptr</span>) &#123;<br>                node-&gt;children[ch] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Trie</span>();<br>            &#125;<br>            node = node-&gt;children[ch];<br>        &#125;<br>        node-&gt;isEnd = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns if the word is in the trie. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">search</span><span class="hljs-params">(string word)</span> </span>&#123;<br>		Trie* node = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">searchPrefix</span>(word);<br>        <span class="hljs-keyword">return</span> node != <span class="hljs-literal">nullptr</span> &amp;&amp; node-&gt;isEnd;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(string prefix)</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">searchPrefix</span>(prefix) != <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your Trie object will be instantiated and called as such:</span><br><span class="hljs-comment"> * Trie* obj = new Trie();</span><br><span class="hljs-comment"> * obj-&gt;insert(word);</span><br><span class="hljs-comment"> * bool param_2 = obj-&gt;search(word);</span><br><span class="hljs-comment"> * bool param_3 = obj-&gt;startsWith(prefix);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>

<h2 id="421-Maximum-XOR-of-Two-Numbers-in-an-Array-数组中的两个数的最大值"><a href="#421-Maximum-XOR-of-Two-Numbers-in-an-Array-数组中的两个数的最大值" class="headerlink" title="421. Maximum XOR of Two Numbers in an Array(数组中的两个数的最大值)"></a>421. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/">Maximum XOR of Two Numbers in an Array(数组中的两个数的最大值)</a></h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><p>Find the 1’s complement of the number bit by bit from highest to lowest<br>we can build a prefix(Trie) to answer whrther there is a number in the array starts with a given substring in O(1)<br>if there is only one path, follow that path, if there are two paths, chose the complement one, e.g. 1 - current_bit</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Trie</span>() : <span class="hljs-built_in">children</span>(<span class="hljs-number">2</span>)&#123;&#125;<br>	vector&lt;Trie*&gt; children;<br>	<br>	<span class="hljs-comment">/** Inserts a num into the trie. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>		Trie* node = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">31</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">int</span> bit = (num &gt;&gt; i) &amp; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (node-&gt;children[bit] == <span class="hljs-literal">nullptr</span>) &#123;<br>                node-&gt;children[bit] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Trie</span>();<br>            &#125;<br>            node = node-&gt;children[bit];<br>        &#125;<br>    &#125;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span></span>&#123;<br>		Trie* node = <span class="hljs-keyword">this</span>;<br>		<span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">31</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">int</span> bit = (num &gt;&gt; i) &amp; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (node-&gt;children[<span class="hljs-number">1</span> - bit] != <span class="hljs-literal">nullptr</span>) &#123;<br>				sum |= (<span class="hljs-number">1</span> &lt;&lt; i);<br>                node = node-&gt;children[<span class="hljs-number">1</span> - bit];<br>            &#125;<br>            <span class="hljs-keyword">else</span> <br>                node = node-&gt;children[bit];<br>        &#125;<br>		<span class="hljs-keyword">return</span> sum;<br>	&#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findMaximumXOR</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>		Trie* obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Trie</span>();<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) obj-&gt;<span class="hljs-built_in">insert</span>(num);<br>		<span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) ans = <span class="hljs-built_in">max</span>(ans, obj-&gt;<span class="hljs-built_in">query</span>(num));<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="1707-Maximum-XOR-With-an-Element-From-Array-与数组中元素的最大异或值"><a href="#1707-Maximum-XOR-With-an-Element-From-Array-与数组中元素的最大异或值" class="headerlink" title="1707. Maximum XOR With an Element From Array(与数组中元素的最大异或值)"></a>1707. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-xor-with-an-element-from-array/">Maximum XOR With an Element From Array(与数组中元素的最大异或值)</a></h2><h3 id="方法一：前缀树"><a href="#方法一：前缀树" class="headerlink" title="方法一：前缀树"></a>方法一：前缀树</h3><p>sort queries by limit<br>sort numbers<br>we can build the trie on the fly: inserting numbers that are less or equal to the limit of the current query, query the trie to find the maximum xor of the current number and numbers in the given array that are &lt;= limit</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Trie</span>() : <span class="hljs-built_in">children</span>(<span class="hljs-number">2</span>)&#123;&#125;<br>	vector&lt;Trie*&gt; children;<br>	<br>	<span class="hljs-comment">/** Inserts a num into the trie. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>		Trie* node = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">31</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">int</span> bit = (num &gt;&gt; i) &amp; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (node-&gt;children[bit] == <span class="hljs-literal">nullptr</span>) &#123;<br>                node-&gt;children[bit] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Trie</span>();<br>            &#125;<br>            node = node-&gt;children[bit];<br>        &#125;<br>    &#125;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span></span>&#123;<br>		Trie* node = <span class="hljs-keyword">this</span>;<br>		<span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">31</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>			<span class="hljs-keyword">if</span>(node == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">int</span> bit = (num &gt;&gt; i) &amp; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (node-&gt;children[<span class="hljs-number">1</span> - bit] != <span class="hljs-literal">nullptr</span>) &#123;<br>				sum |= (<span class="hljs-number">1</span> &lt;&lt; i);<br>                node = node-&gt;children[<span class="hljs-number">1</span> - bit];<br>            &#125;<br>            <span class="hljs-keyword">else</span> <br>                node = node-&gt;children[bit];<br>        &#125;<br>		<span class="hljs-keyword">return</span> sum;<br>	&#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">maximizeXor</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;<br>		<span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>		<span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>		<span class="hljs-keyword">int</span> Q = queries.<span class="hljs-built_in">size</span>();<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; Q; i++)<br>			queries[i].<span class="hljs-built_in">push_back</span>(i);<br>		<span class="hljs-built_in">sort</span>(queries.<span class="hljs-built_in">begin</span>(), queries.<span class="hljs-built_in">end</span>(), [](<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; q1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; q2)&#123;<span class="hljs-keyword">return</span> q1[<span class="hljs-number">1</span>] &lt; q2[<span class="hljs-number">1</span>];&#125;);<br>		Trie* obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Trie</span>();<br>		<span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(Q)</span></span>;<br>		<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; q : queries)&#123;<br>			<span class="hljs-keyword">while</span> (i &lt; n &amp;&amp; nums[i] &lt;= q[<span class="hljs-number">1</span>])&#123;<br>				obj-&gt;<span class="hljs-built_in">insert</span>(nums[i]);<br>				i++;<br>			&#125;<br>			ans[q[<span class="hljs-number">2</span>]] = obj-&gt;<span class="hljs-built_in">query</span>(q[<span class="hljs-number">0</span>]);<br>		&#125;<br>		<span class="hljs-keyword">return</span> ans;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(root) &#123;<br>            <span class="hljs-keyword">if</span> (root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val) &#123;<br>                root = root-&gt;left;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val) &#123;<br>                root = root-&gt;right;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a>235. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">二叉搜索树的最近公共祖先</a></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> cur;<br>                                                        <span class="hljs-comment">// 中</span><br>        <span class="hljs-keyword">if</span> (cur-&gt;val &gt; p-&gt;val &amp;&amp; cur-&gt;val &gt; q-&gt;val) &#123;   <span class="hljs-comment">// 左</span><br>            TreeNode* left = <span class="hljs-built_in">traversal</span>(cur-&gt;left, p, q);<br>            <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">NULL</span>) &#123;<br>                <span class="hljs-keyword">return</span> left;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (cur-&gt;val &lt; p-&gt;val &amp;&amp; cur-&gt;val &lt; q-&gt;val) &#123;   <span class="hljs-comment">// 右</span><br>            TreeNode* right = <span class="hljs-built_in">traversal</span>(cur-&gt;right, p, q);<br>            <span class="hljs-keyword">if</span> (right != <span class="hljs-literal">NULL</span>) &#123;<br>                <span class="hljs-keyword">return</span> right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cur;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">traversal</span>(root, p, q);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a>236. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">二叉树的最近公共祖先</a></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == q || root == p || root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br>        TreeNode* left = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);<br>        TreeNode* right = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<br>        <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">NULL</span> &amp;&amp; right != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br><br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">NULL</span> &amp;&amp; right != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> right;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">NULL</span> &amp;&amp; right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> left;<br>        <span class="hljs-keyword">else</span>  &#123; <span class="hljs-comment">//  (left == NULL &amp;&amp; right == NULL)</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="506-二叉搜索树中的众数"><a href="#506-二叉搜索树中的众数" class="headerlink" title="506. 二叉搜索树中的众数"></a>506. <a href="">二叉搜索树中的众数</a></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> maxCount; <span class="hljs-comment">// 最大频率</span><br>    <span class="hljs-keyword">int</span> count; <span class="hljs-comment">// 统计频率</span><br>    TreeNode* pre;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; result;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">searchBST</span><span class="hljs-params">(TreeNode* cur)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> ;<br><br>        <span class="hljs-built_in">searchBST</span>(cur-&gt;left);       <span class="hljs-comment">// 左</span><br>                                    <span class="hljs-comment">// 中</span><br>        <span class="hljs-keyword">if</span> (pre == <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">// 第一个节点</span><br>            count = <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pre-&gt;val == cur-&gt;val) &#123; <span class="hljs-comment">// 与前一个节点数值相同</span><br>            count++;<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 与前一个节点数值不同</span><br>            count = <span class="hljs-number">1</span>;<br>        &#125;<br>        pre = cur; <span class="hljs-comment">// 更新上一个节点</span><br><br>        <span class="hljs-keyword">if</span> (count == maxCount) &#123; <span class="hljs-comment">// 如果和最大值相同，放进result中</span><br>            result.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (count &gt; maxCount) &#123; <span class="hljs-comment">// 如果计数大于最大值频率</span><br>            maxCount = count;   <span class="hljs-comment">// 更新最大频率</span><br>            result.<span class="hljs-built_in">clear</span>();     <span class="hljs-comment">// 很关键的一步，不要忘记清空result，之前result里的元素都失效了</span><br>            result.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>        &#125;<br><br>        <span class="hljs-built_in">searchBST</span>(cur-&gt;right);      <span class="hljs-comment">// 右</span><br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">findMode</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        count = <span class="hljs-number">0</span>; <br>        maxCount = <span class="hljs-number">0</span>;<br>        TreeNode* pre = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 记录前一个节点</span><br>        result.<span class="hljs-built_in">clear</span>();<br><br>        <span class="hljs-built_in">searchBST</span>(root);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="如果不是二叉搜索树"><a href="#如果不是二叉搜索树" class="headerlink" title="如果不是二叉搜索树"></a>如果不是二叉搜索树</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">searchBST</span><span class="hljs-params">(TreeNode* cur, unordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&amp; map)</span> </span>&#123; <span class="hljs-comment">// 前序遍历</span><br>    <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> ;<br>    map[cur-&gt;val]++; <span class="hljs-comment">// 统计元素频率</span><br>    <span class="hljs-built_in">searchBST</span>(cur-&gt;left, map);<br>    <span class="hljs-built_in">searchBST</span>(cur-&gt;right, map);<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-keyword">static</span> <span class="hljs-title">cmp</span> <span class="hljs-params">(<span class="hljs-keyword">const</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&amp; a, <span class="hljs-keyword">const</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&amp; b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a.second &gt; b.second;<br>&#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">findMode</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; map; <span class="hljs-comment">// key:元素，value:出现频率</span><br>        vector&lt;<span class="hljs-keyword">int</span>&gt; result;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> result;<br>        <span class="hljs-built_in">searchBST</span>(root, map);<br>        vector&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">vec</span>(map.<span class="hljs-built_in">begin</span>(), map.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), cmp); <span class="hljs-comment">// 给频率排个序</span><br>        result.<span class="hljs-built_in">push_back</span>(vec[<span class="hljs-number">0</span>].first);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; vec.<span class="hljs-built_in">size</span>(); i++) &#123; <br>            <span class="hljs-comment">// 取最高的放到result数组中</span><br>            <span class="hljs-keyword">if</span> (vec[i].second == vec[<span class="hljs-number">0</span>].second) result.<span class="hljs-built_in">push_back</span>(vec[i].first);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;c<br></code></pre></td></tr></table></figure>



<h2 id="1617-Count-Subtrees-With-Max-Distance-Between-Cities-统计子树中城市之间的最大距离"><a href="#1617-Count-Subtrees-With-Max-Distance-Between-Cities-统计子树中城市之间的最大距离" class="headerlink" title="1617. Count Subtrees With Max Distance Between Cities(统计子树中城市之间的最大距离)"></a>1617. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-subtrees-with-max-distance-between-cities/">Count Subtrees With Max Distance Between Cities(统计子树中城市之间的最大距离)</a></h2><h3 id="方法一：Brute-Force"><a href="#方法一：Brute-Force" class="headerlink" title="方法一：Brute Force"></a>方法一：Brute Force</h3><p>Enumerate all subsets and check the maximum distance<br>Note: A subset might not form a tree.<br>Try all subtrees and find the diameter of that subtree (longest distance between any node)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function">pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">bfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; g, queue&lt;<span class="hljs-keyword">int</span>&gt;&amp; q, <span class="hljs-keyword">int</span> start, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; seen, <span class="hljs-keyword">int</span>&amp; last)</span></span>&#123;<br>        q.<span class="hljs-built_in">push</span>(start);<br>        seen[start] = <span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>, dist = <span class="hljs-number">-1</span>;<br>		<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>			<span class="hljs-keyword">int</span> s = q.<span class="hljs-built_in">size</span>();        <br>			<span class="hljs-keyword">while</span> (s--) &#123;<br>                last = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>                ++count;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v : g[last])<br>				    <span class="hljs-keyword">if</span> (seen[v] != <span class="hljs-number">-1</span> &amp;&amp; !seen[v]++) q.<span class="hljs-built_in">push</span>(v);<br>			&#125;<br>			++dist;<br>		&#125;<br>		<span class="hljs-keyword">return</span> &#123;dist, count&#125;;<br>	&#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">countSubgraphsForEachDiameter</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">g</span>(n);<br>        <span class="hljs-comment">//根据边建立无向图</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; e : edges)<br>            g[e[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>].<span class="hljs-built_in">push_back</span>(e[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>), g[e[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>].<span class="hljs-built_in">push_back</span>(e[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>);<br>        <br>        <span class="hljs-keyword">int</span> last = <span class="hljs-number">-1</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">seen</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span>, seen2</span>;<br>        queue&lt;<span class="hljs-keyword">int</span>&gt; q;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n - <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> s = <span class="hljs-number">0</span>; s &lt; <span class="hljs-number">1</span> &lt;&lt; n; ++s) &#123;<br>            <span class="hljs-keyword">if</span> (__builtin_popcount(s) &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-built_in">fill</span>(<span class="hljs-built_in">begin</span>(seen), <span class="hljs-built_in">end</span>(seen), <span class="hljs-number">-1</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)&#123; <br>                <span class="hljs-keyword">if</span> (s &amp; (<span class="hljs-number">1</span> &lt;&lt; i)) <br>                    seen[i] = <span class="hljs-number">0</span>;<br>            &#125;<br>            seen2 = seen;<br>            <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> start = <span class="hljs-number">31</span> - __builtin_clz(s &amp; (s - <span class="hljs-number">1</span>));<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">bfs</span>(g, q, start, seen, last).second != __builtin_popcount(s)) <span class="hljs-keyword">continue</span>;      <br>            ++ans[<span class="hljs-built_in">bfs</span>(g, q, last, seen2, last).first - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="方法二：DP-on-Trees"><a href="#方法二：DP-on-Trees" class="headerlink" title="方法二：DP on Trees"></a>方法二：DP on Trees</h3><p>use each node as root, build subtrees by recursively build subtrees of its children as roots and merge them to form large subtrees.<br>avoid duplication<br><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="9.496ex" height="2.843ex" style="vertical-align: -0.838ex;" viewBox="0 -863.1 4088.5 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">dp[i][k][d]</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMATHI-64" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path>
<path stroke-width="1" id="E1-MJMATHI-70" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"></path>
<path stroke-width="1" id="E1-MJMAIN-5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path>
<path stroke-width="1" id="E1-MJMATHI-69" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path>
<path stroke-width="1" id="E1-MJMAIN-5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path>
<path stroke-width="1" id="E1-MJMATHI-6B" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMATHI-64" x="0" y="0"></use>
 <use xlink:href="#E1-MJMATHI-70" x="523" y="0"></use>
 <use xlink:href="#E1-MJMAIN-5B" x="1027" y="0"></use>
 <use xlink:href="#E1-MJMATHI-69" x="1305" y="0"></use>
 <use xlink:href="#E1-MJMAIN-5D" x="1651" y="0"></use>
 <use xlink:href="#E1-MJMAIN-5B" x="1929" y="0"></use>
 <use xlink:href="#E1-MJMATHI-6B" x="2208" y="0"></use>
 <use xlink:href="#E1-MJMAIN-5D" x="2729" y="0"></use>
 <use xlink:href="#E1-MJMAIN-5B" x="3008" y="0"></use>
 <use xlink:href="#E1-MJMATHI-64" x="3286" y="0"></use>
 <use xlink:href="#E1-MJMAIN-5D" x="3810" y="0"></use>
</g>
</svg> = # of subtrees rooting at i that has tree diameter of d, k is the longest path that does not passing i (or distance from i to the farthest node)<br><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="13.655ex" height="2.843ex" style="vertical-align: -0.838ex;" viewBox="0 -863.1 5879.1 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">dp[i][0][0] = 1</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMATHI-64" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path>
<path stroke-width="1" id="E1-MJMATHI-70" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"></path>
<path stroke-width="1" id="E1-MJMAIN-5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path>
<path stroke-width="1" id="E1-MJMATHI-69" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path>
<path stroke-width="1" id="E1-MJMAIN-5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path>
<path stroke-width="1" id="E1-MJMAIN-30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path>
<path stroke-width="1" id="E1-MJMAIN-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path>
<path stroke-width="1" id="E1-MJMAIN-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMATHI-64" x="0" y="0"></use>
 <use xlink:href="#E1-MJMATHI-70" x="523" y="0"></use>
 <use xlink:href="#E1-MJMAIN-5B" x="1027" y="0"></use>
 <use xlink:href="#E1-MJMATHI-69" x="1305" y="0"></use>
 <use xlink:href="#E1-MJMAIN-5D" x="1651" y="0"></use>
 <use xlink:href="#E1-MJMAIN-5B" x="1929" y="0"></use>
 <use xlink:href="#E1-MJMAIN-30" x="2208" y="0"></use>
 <use xlink:href="#E1-MJMAIN-5D" x="2708" y="0"></use>
 <use xlink:href="#E1-MJMAIN-5B" x="2987" y="0"></use>
 <use xlink:href="#E1-MJMAIN-30" x="3265" y="0"></use>
 <use xlink:href="#E1-MJMAIN-5D" x="3766" y="0"></use>
 <use xlink:href="#E1-MJMAIN-3D" x="4322" y="0"></use>
 <use xlink:href="#E1-MJMAIN-31" x="5378" y="0"></use>
</g>
</svg>, a subtree of a single node i, d = k = 0<br>Enumerate existing subtrees rooted at u of (k1,d1) and merge with subtrees rooted at v of (k2,d2) where there is an edge between u and v<br><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="46.08ex" height="2.843ex" style="vertical-align: -0.838ex;" viewBox="0 -863.1 19840 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">dp[u][k][d] = sum(dp[u][k1][d1] * dp[v][k2][d2])</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMATHI-64" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path>
<path stroke-width="1" id="E1-MJMATHI-70" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"></path>
<path stroke-width="1" id="E1-MJMAIN-5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path>
<path stroke-width="1" id="E1-MJMATHI-75" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path>
<path stroke-width="1" id="E1-MJMAIN-5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path>
<path stroke-width="1" id="E1-MJMATHI-6B" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path>
<path stroke-width="1" id="E1-MJMAIN-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path>
<path stroke-width="1" id="E1-MJMATHI-73" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path>
<path stroke-width="1" id="E1-MJMATHI-6D" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path>
<path stroke-width="1" id="E1-MJMAIN-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path>
<path stroke-width="1" id="E1-MJMAIN-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path>
<path stroke-width="1" id="E1-MJMAIN-2217" d="M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z"></path>
<path stroke-width="1" id="E1-MJMATHI-76" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path>
<path stroke-width="1" id="E1-MJMAIN-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path>
<path stroke-width="1" id="E1-MJMAIN-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMATHI-64" x="0" y="0"></use>
 <use xlink:href="#E1-MJMATHI-70" x="523" y="0"></use>
 <use xlink:href="#E1-MJMAIN-5B" x="1027" y="0"></use>
 <use xlink:href="#E1-MJMATHI-75" x="1305" y="0"></use>
 <use xlink:href="#E1-MJMAIN-5D" x="1878" y="0"></use>
 <use xlink:href="#E1-MJMAIN-5B" x="2156" y="0"></use>
 <use xlink:href="#E1-MJMATHI-6B" x="2435" y="0"></use>
 <use xlink:href="#E1-MJMAIN-5D" x="2956" y="0"></use>
 <use xlink:href="#E1-MJMAIN-5B" x="3235" y="0"></use>
 <use xlink:href="#E1-MJMATHI-64" x="3513" y="0"></use>
 <use xlink:href="#E1-MJMAIN-5D" x="4037" y="0"></use>
 <use xlink:href="#E1-MJMAIN-3D" x="4593" y="0"></use>
 <use xlink:href="#E1-MJMATHI-73" x="5649" y="0"></use>
 <use xlink:href="#E1-MJMATHI-75" x="6119" y="0"></use>
 <use xlink:href="#E1-MJMATHI-6D" x="6691" y="0"></use>
 <use xlink:href="#E1-MJMAIN-28" x="7570" y="0"></use>
 <use xlink:href="#E1-MJMATHI-64" x="7959" y="0"></use>
 <use xlink:href="#E1-MJMATHI-70" x="8483" y="0"></use>
 <use xlink:href="#E1-MJMAIN-5B" x="8986" y="0"></use>
 <use xlink:href="#E1-MJMATHI-75" x="9265" y="0"></use>
 <use xlink:href="#E1-MJMAIN-5D" x="9837" y="0"></use>
 <use xlink:href="#E1-MJMAIN-5B" x="10116" y="0"></use>
 <use xlink:href="#E1-MJMATHI-6B" x="10394" y="0"></use>
 <use xlink:href="#E1-MJMAIN-31" x="10916" y="0"></use>
 <use xlink:href="#E1-MJMAIN-5D" x="11416" y="0"></use>
 <use xlink:href="#E1-MJMAIN-5B" x="11695" y="0"></use>
 <use xlink:href="#E1-MJMATHI-64" x="11973" y="0"></use>
 <use xlink:href="#E1-MJMAIN-31" x="12497" y="0"></use>
 <use xlink:href="#E1-MJMAIN-5D" x="12997" y="0"></use>
 <use xlink:href="#E1-MJMAIN-2217" x="13498" y="0"></use>
 <use xlink:href="#E1-MJMATHI-64" x="14221" y="0"></use>
 <use xlink:href="#E1-MJMATHI-70" x="14744" y="0"></use>
 <use xlink:href="#E1-MJMAIN-5B" x="15248" y="0"></use>
 <use xlink:href="#E1-MJMATHI-76" x="15526" y="0"></use>
 <use xlink:href="#E1-MJMAIN-5D" x="16012" y="0"></use>
 <use xlink:href="#E1-MJMAIN-5B" x="16290" y="0"></use>
 <use xlink:href="#E1-MJMATHI-6B" x="16569" y="0"></use>
 <use xlink:href="#E1-MJMAIN-32" x="17090" y="0"></use>
 <use xlink:href="#E1-MJMAIN-5D" x="17591" y="0"></use>
 <use xlink:href="#E1-MJMAIN-5B" x="17869" y="0"></use>
 <use xlink:href="#E1-MJMATHI-64" x="18148" y="0"></use>
 <use xlink:href="#E1-MJMAIN-32" x="18671" y="0"></use>
 <use xlink:href="#E1-MJMAIN-5D" x="19172" y="0"></use>
 <use xlink:href="#E1-MJMAIN-29" x="19450" y="0"></use>
</g>
</svg> where k = max(k1, k2 + 1), d = max(d1, d2, k1 + k2 + 1)<br>Enumerate all node from 0 to n - 1, and use it as root to build subtrees.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> p, vector&lt;vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&gt;&amp; dp, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; sizes, <span class="hljs-keyword">int</span> n, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; g)</span></span>&#123;<br>		<span class="hljs-keyword">if</span>(!dp[u].<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span>;<br>		dp[u] = vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;(n, vector&lt;<span class="hljs-keyword">int</span>&gt;(n));<br>		dp[u][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>		sizes[u] = <span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v : g[u]) &#123;<br>			<span class="hljs-keyword">if</span> (v == p) <span class="hljs-keyword">continue</span>;<br>			<span class="hljs-built_in">dfs</span>(v, u, dp, sizes, n, g);<br>			vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dpu</span>(dp[u]);<br>			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> d1 = <span class="hljs-number">0</span>; d1 &lt; sizes[u]; ++d1)&#123;<br>				<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k1 = <span class="hljs-number">0</span>; k1 &lt;= d1; ++k1) &#123;<br>					<span class="hljs-keyword">if</span> (!dp[u][k1][d1]) <span class="hljs-keyword">continue</span>;<br>					<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> d2 = <span class="hljs-number">0</span>; d2 &lt; sizes[v]; ++d2)&#123;<br>						<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k2 = <span class="hljs-number">0</span>; k2 &lt;= d2; ++k2) &#123;<br>							<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> d = <span class="hljs-built_in">max</span>(&#123;d1, d2, k1 + k2 + <span class="hljs-number">1</span>&#125;);<br>							<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> k = <span class="hljs-built_in">max</span>(k1, k2 + <span class="hljs-number">1</span>);<br>							dpu[k][d] += dp[u][k1][d1] * dp[v][k2][d2];<br>						&#125;<br>					&#125;<br>				&#125;<br>			&#125;<br>			<span class="hljs-built_in">swap</span>(dpu, dp[u]);<br>			sizes[u] += sizes[v];<br>		&#125;<br>	&#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">countSubgraphsForEachDiameter</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;<br>		vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">g</span>(n);<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; e : edges) &#123;<br>			g[e[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>].<span class="hljs-built_in">push_back</span>(e[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>);<br>			g[e[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>].<span class="hljs-built_in">push_back</span>(e[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>);<br>		&#125;<br>		vector&lt;vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&gt; <span class="hljs-built_in">dp</span>(n);    <br>		<span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sizes</span><span class="hljs-params">(n)</span></span>;<br>		<span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n - <span class="hljs-number">1</span>)</span></span>;<br>		<span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, dp, sizes, n, g);<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <br>		  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; n; ++k)<br>			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> d = <span class="hljs-number">1</span>; d &lt; n; ++d)<br>			  ans[d - <span class="hljs-number">1</span>] += dp[i][k][d];<br>		<span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="1530-Number-of-Good-Leaf-Nodes-Pairs-好叶子结点对的数量"><a href="#1530-Number-of-Good-Leaf-Nodes-Pairs-好叶子结点对的数量" class="headerlink" title="1530. Number of Good Leaf Nodes Pairs(好叶子结点对的数量)"></a>1530. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-good-leaf-nodes-pairs/">Number of Good Leaf Nodes Pairs(好叶子结点对的数量)</a></h2><h3 id="方法一：Brute-Force-1"><a href="#方法一：Brute-Force-1" class="headerlink" title="方法一：Brute Force"></a>方法一：Brute Force</h3><p>collect all leaf nodes(O(n))<br>enumerate all pairs(O(n^2)), check the distance between two nodes(O(10))<br>def distance(A, B):<br>    C = LCA(A, B)<br>    return steps(C, A) + steps(B, C)<br>def LCA(A, B):<br>    seen = {}<br>    while A: seen.add(A), A = parent[A]<br>    while B:<br>        if B in seen: return Balanced<br>        B = parent[B]<br>Since n &lt;= 10^10, and distance &lt;= 10, we can collect all leaf nodes and try all pairs.<br>Time complexity: O(|leaves|^2)<br>Space complexity: O(n)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countPairs</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> distance)</span> </span>&#123;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="方法二：Recursion"><a href="#方法二：Recursion" class="headerlink" title="方法二：Recursion"></a>方法二：Recursion</h3><p>for each node, can we return something that can help solve this problem?<br>let us return a map: {distance, # of leaf nodes}<br>def dfs(node):<br>    if not node: return {0,0}<br>    if is_leaf(node): return {0,1}<br>    l = dfs(node.left)<br>    r = dfs(node.right)<br>    for dl, cl in l:<br>        for dr, cr in r:<br>            ans = ans + cl * cr if dl + dr + 2 &lt;= D else 0<br>    rtn = {}<br>    for d = 0 to D:<br>        rtn[d+1] = l[d] + r[d]<br>    return rtn</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* cur, <span class="hljs-keyword">int</span> distance, <span class="hljs-keyword">int</span>&amp; ans)</span></span>&#123;<br>		<span class="hljs-comment">// f[i] = number of leaves node at distance i.</span><br>		<span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(distance + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>		<span class="hljs-keyword">if</span> (!cur) <span class="hljs-keyword">return</span> f;<br>		<span class="hljs-keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right)&#123;<br>			f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>			<span class="hljs-keyword">return</span> f;<br>		&#125;<br>		<span class="hljs-keyword">const</span> vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; l = <span class="hljs-built_in">dfs</span>(cur-&gt;left, distance, ans);<br>		<span class="hljs-keyword">const</span> vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; r = <span class="hljs-built_in">dfs</span>(cur-&gt;right, distance, ans);<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= distance; i++)&#123;<br>			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= distance; j++)&#123;<br>				<span class="hljs-keyword">if</span> (i + j + <span class="hljs-number">2</span> &lt;= distance)<br>					ans += l[i] * r[j];<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; distance; i++)&#123;<br>			f[i + <span class="hljs-number">1</span>] = l[i] + r[i];<br>		&#125;<br>		<span class="hljs-keyword">return</span> f;<br>	&#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countPairs</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> distance)</span> </span>&#123;<br>		<span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>		<span class="hljs-built_in">dfs</span>(root, distance, ans);<br>		<span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="662-Maximum-Width-of-Binary-Tree-二叉树的最大宽度"><a href="#662-Maximum-Width-of-Binary-Tree-二叉树的最大宽度" class="headerlink" title="662. Maximum Width of Binary Tree(二叉树的最大宽度)"></a>662. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-width-of-binary-tree/">Maximum Width of Binary Tree(二叉树的最大宽度)</a></h2><p>每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。<br>we can assign an unique id to each node<br>root is 1, left = parent * 2, right = parent * 2 + 1</p>
<p>Width = id(right most child) – id(left most child) + 1</p>
<p>offset the ids: every node minus the min id of each level</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">widthOfBinaryTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; ids; <span class="hljs-comment">// left most id of each level.</span><br>        function&lt;<span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(TreeNode*, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)&gt; dfs = [&amp;](TreeNode* node, <span class="hljs-keyword">int</span> d, <span class="hljs-keyword">int</span> id) -&gt; <span class="hljs-keyword">int</span> &#123;<br>          <span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>          <span class="hljs-keyword">if</span> (d == ids.<span class="hljs-built_in">size</span>()) ids.<span class="hljs-built_in">push_back</span>(id);<br>          <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(&#123;id - ids[d] + <span class="hljs-number">1</span>, <br>                     <span class="hljs-built_in">dfs</span>(node-&gt;left, d + <span class="hljs-number">1</span>, (id - ids[d]) * <span class="hljs-number">2</span>), <br>                     <span class="hljs-built_in">dfs</span>(node-&gt;right, d + <span class="hljs-number">1</span>, (id - ids[d]) * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>)&#125;);<br>        &#125;;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="1489-Find-Critical-and-Pseudo-Critical-Edges-in-Minimum-Spanning-Tree-找到最小生成树里的关键边和伪关键边"><a href="#1489-Find-Critical-and-Pseudo-Critical-Edges-in-Minimum-Spanning-Tree-找到最小生成树里的关键边和伪关键边" class="headerlink" title="1489. Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree(找到最小生成树里的关键边和伪关键边)"></a>1489. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/">Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree(找到最小生成树里的关键边和伪关键边)</a></h2><p>关键边：如果从图中删去某条边，会导致最小生成树的权值和增加或者不构成最小生成树，则是一条关键边。</p>
<p>伪关键边：可能会出现在某些最小生成树中但不会出现在所有最小生成树中的边。</p>
<h3 id="方法一：Kruskal-disjoint-set-union-find"><a href="#方法一：Kruskal-disjoint-set-union-find" class="headerlink" title="方法一：Kruskal, disjoint-set/union-find"></a>方法一：Kruskal, disjoint-set/union-find</h3><p>MST: Kruskal, disjoint-set/union-find<br>edge &lt;= 200 =&gt; for every edge, do sth and build a MST<br><font color=red>Critical edge:</font> 删除</p>
<ol>
<li>cost increased if removed</li>
<li>can not form a tree anymore if removed</li>
</ol>
<p><font color=red>Pseudo-Critical: </font>加入 include it and cost should remain the same</p>
<ol>
<li>record original edge id.</li>
<li>sort edges by weight (do it only once)</li>
<li>build a MST w/o modifying any edge to get the min_cost</li>
<li>for edge<br>a. exclude it and build MST to find critical<br>b. include it and build MST to find pseudo-critical</li>
</ol>
<p>Time complexity: O(elonge) + O(e^2)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span> &#123;</span><br>	<span class="hljs-keyword">public</span>:<br>		<span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">UnionFind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span>: p_(n), r_(n) &#123;</span> <span class="hljs-built_in">iota</span>(<span class="hljs-built_in">begin</span>(p_), <span class="hljs-built_in">end</span>(p_), <span class="hljs-number">0</span>); &#125; <span class="hljs-comment">// e.g. p[i] = i</span><br>		<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> p_[x] == x ? x : p_[x] = <span class="hljs-built_in">Find</span>(p_[x]); &#125;<br>		<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>			<span class="hljs-keyword">int</span> rx = <span class="hljs-built_in">Find</span>(x);<br>			<span class="hljs-keyword">int</span> ry = <span class="hljs-built_in">Find</span>(y);<br>			<span class="hljs-keyword">if</span> (rx == ry) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>			<span class="hljs-keyword">if</span> (r_[rx] == r_[ry]) &#123;<br>				p_[rx] = ry;<br>				++r_[ry];<br>			&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (r_[rx] &gt; r_[ry]) &#123;<br>				p_[ry] = rx;<br>			&#125; <span class="hljs-keyword">else</span> &#123;<br>				p_[rx] = ry;<br>			&#125;    <br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>		&#125;<br>	<span class="hljs-keyword">private</span>:<br>		vector&lt;<span class="hljs-keyword">int</span>&gt; p_, r_;  <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MST</span><span class="hljs-params">( <span class="hljs-keyword">int</span> n, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; edges, <span class="hljs-keyword">int</span> ex = <span class="hljs-number">-1</span>, <span class="hljs-keyword">int</span> in = <span class="hljs-number">-1</span>)</span></span>&#123;<br>		<span class="hljs-function">UnionFind <span class="hljs-title">uf</span><span class="hljs-params">(n)</span></span>;<br>		<span class="hljs-keyword">int</span> cost = <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">if</span> (in &gt;= <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//边in必须加入</span><br>			cost += edges[in][<span class="hljs-number">2</span>];<br>			uf.<span class="hljs-built_in">Union</span>(edges[in][<span class="hljs-number">0</span>], edges[in][<span class="hljs-number">1</span>]);<br>			count++;<br>		&#125;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; edges.<span class="hljs-built_in">size</span>(); ++i) &#123;        <br>			<span class="hljs-keyword">if</span> (i == ex) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">//边i是需要remove的边</span><br>			<span class="hljs-keyword">if</span> (!uf.<span class="hljs-built_in">Union</span>(edges[i][<span class="hljs-number">0</span>], edges[i][<span class="hljs-number">1</span>])) <span class="hljs-keyword">continue</span>;<br>			cost += edges[i][<span class="hljs-number">2</span>];<br>			++count;<br>		&#125;<br>		<span class="hljs-keyword">return</span> count == n - <span class="hljs-number">1</span> ? cost : INT_MAX;<br>	&#125;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">findCriticalAndPseudoCriticalEdges</span>(<span class="hljs-keyword">int</span> n, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; edges) &#123;<br>		<span class="hljs-comment">// Record the original id.</span><br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; edges.<span class="hljs-built_in">size</span>(); ++i) edges[i].<span class="hljs-built_in">push_back</span>(i);<br>		<span class="hljs-comment">// Sort edges by weight.</span><br>		<span class="hljs-built_in">sort</span>(<span class="hljs-built_in">begin</span>(edges), <span class="hljs-built_in">end</span>(edges), [&amp;](<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; e1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; e2)&#123;<br>		<span class="hljs-keyword">if</span> (e1[<span class="hljs-number">2</span>] != e2[<span class="hljs-number">2</span>]) <span class="hljs-keyword">return</span> e1[<span class="hljs-number">2</span>] &lt; e2[<span class="hljs-number">2</span>];        <br>			<span class="hljs-keyword">return</span> e1 &lt; e2;<br>		&#125;);<br>		<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> min_cost = <span class="hljs-built_in">MST</span>(n, edges);<br>		vector&lt;<span class="hljs-keyword">int</span>&gt; criticals;<br>		vector&lt;<span class="hljs-keyword">int</span>&gt; pseudos;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; edges.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>			<span class="hljs-keyword">if</span> (<span class="hljs-built_in">MST</span>(n, edges, i) &gt; min_cost) <span class="hljs-comment">//去掉i边</span><br>				criticals.<span class="hljs-built_in">push_back</span>(edges[i][<span class="hljs-number">3</span>]);<br>			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">MST</span>(n, edges, <span class="hljs-number">-1</span>, i) == min_cost) <span class="hljs-comment">//强制加入i边</span><br>				pseudos.<span class="hljs-built_in">push_back</span>(edges[i][<span class="hljs-number">3</span>]);<br>		&#125;<br>		<span class="hljs-keyword">return</span> &#123;criticals, pseudos&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="1483-Kth-Ancestor-of-a-Tree-Node-树结点的第K个祖先"><a href="#1483-Kth-Ancestor-of-a-Tree-Node-树结点的第K个祖先" class="headerlink" title="1483. Kth Ancestor of a Tree Node(树结点的第K个祖先)"></a>1483. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kth-ancestor-of-a-tree-node/">Kth Ancestor of a Tree Node(树结点的第K个祖先)</a></h2><h3 id="方法一：Brute-Force-2"><a href="#方法一：Brute-Force-2" class="headerlink" title="方法一：Brute Force"></a>方法一：Brute Force</h3><h3 id="方法二：动态规划"><a href="#方法二：动态规划" class="headerlink" title="方法二：动态规划"></a>方法二：动态规划</h3><p>Let A(x,k) denote x’s k-th ancestor<br>A(x, k) = A(A(x, t), k - t), 1 &lt;= t &lt; k<br>A(x, 0) = x<br>A(0, &gt;0) = -1<br>Each node stores it’s 2^0-th, 2^1-th,……, 2^p-th’s ancestors, at most O(log2(n))<br>we can jump along the ancestor table. Each time, take one bit off k (can be highest or lowest).<br>Query: popcount(k), O(logk)<br>Build the ancestor table:</p>
<ol>
<li>Build the graph and traverse the tree<br>a. record the current path along the way.<br>b. for each node, store the 2^i-th ancestors in the path.<br>c. Time complexity: O(nlogn)<br>d. Space complexity: O(nlogn)</li>
<li>DP<br>a. <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="6.733ex" height="2.843ex" style="vertical-align: -0.838ex;" viewBox="0 -863.1 2899 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">dp[i][j]</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMATHI-64" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path>
<path stroke-width="1" id="E1-MJMATHI-70" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"></path>
<path stroke-width="1" id="E1-MJMAIN-5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path>
<path stroke-width="1" id="E1-MJMATHI-69" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path>
<path stroke-width="1" id="E1-MJMAIN-5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path>
<path stroke-width="1" id="E1-MJMATHI-6A" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMATHI-64" x="0" y="0"></use>
 <use xlink:href="#E1-MJMATHI-70" x="523" y="0"></use>
 <use xlink:href="#E1-MJMAIN-5B" x="1027" y="0"></use>
 <use xlink:href="#E1-MJMATHI-69" x="1305" y="0"></use>
 <use xlink:href="#E1-MJMAIN-5D" x="1651" y="0"></use>
 <use xlink:href="#E1-MJMAIN-5B" x="1929" y="0"></use>
 <use xlink:href="#E1-MJMATHI-6A" x="2208" y="0"></use>
 <use xlink:href="#E1-MJMAIN-5D" x="2620" y="0"></use>
</g>
</svg> = node j’s 2^i-th ancestors<br>b. <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="30.346ex" height="2.843ex" style="vertical-align: -0.838ex;" viewBox="0 -863.1 13065.4 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">dp[i][j] = dp[i-1][dp[i-1][j]]</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMATHI-64" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path>
<path stroke-width="1" id="E1-MJMATHI-70" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"></path>
<path stroke-width="1" id="E1-MJMAIN-5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path>
<path stroke-width="1" id="E1-MJMATHI-69" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path>
<path stroke-width="1" id="E1-MJMAIN-5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path>
<path stroke-width="1" id="E1-MJMATHI-6A" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"></path>
<path stroke-width="1" id="E1-MJMAIN-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path>
<path stroke-width="1" id="E1-MJMAIN-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path>
<path stroke-width="1" id="E1-MJMAIN-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMATHI-64" x="0" y="0"></use>
 <use xlink:href="#E1-MJMATHI-70" x="523" y="0"></use>
 <use xlink:href="#E1-MJMAIN-5B" x="1027" y="0"></use>
 <use xlink:href="#E1-MJMATHI-69" x="1305" y="0"></use>
 <use xlink:href="#E1-MJMAIN-5D" x="1651" y="0"></use>
 <use xlink:href="#E1-MJMAIN-5B" x="1929" y="0"></use>
 <use xlink:href="#E1-MJMATHI-6A" x="2208" y="0"></use>
 <use xlink:href="#E1-MJMAIN-5D" x="2620" y="0"></use>
 <use xlink:href="#E1-MJMAIN-3D" x="3176" y="0"></use>
 <use xlink:href="#E1-MJMATHI-64" x="4233" y="0"></use>
 <use xlink:href="#E1-MJMATHI-70" x="4756" y="0"></use>
 <use xlink:href="#E1-MJMAIN-5B" x="5260" y="0"></use>
 <use xlink:href="#E1-MJMATHI-69" x="5538" y="0"></use>
 <use xlink:href="#E1-MJMAIN-2212" x="6106" y="0"></use>
 <use xlink:href="#E1-MJMAIN-31" x="7107" y="0"></use>
 <use xlink:href="#E1-MJMAIN-5D" x="7607" y="0"></use>
 <use xlink:href="#E1-MJMAIN-5B" x="7886" y="0"></use>
 <use xlink:href="#E1-MJMATHI-64" x="8164" y="0"></use>
 <use xlink:href="#E1-MJMATHI-70" x="8688" y="0"></use>
 <use xlink:href="#E1-MJMAIN-5B" x="9191" y="0"></use>
 <use xlink:href="#E1-MJMATHI-69" x="9470" y="0"></use>
 <use xlink:href="#E1-MJMAIN-2212" x="10037" y="0"></use>
 <use xlink:href="#E1-MJMAIN-31" x="11038" y="0"></use>
 <use xlink:href="#E1-MJMAIN-5D" x="11538" y="0"></use>
 <use xlink:href="#E1-MJMAIN-5B" x="11817" y="0"></use>
 <use xlink:href="#E1-MJMATHI-6A" x="12095" y="0"></use>
 <use xlink:href="#E1-MJMAIN-5D" x="12508" y="0"></use>
 <use xlink:href="#E1-MJMAIN-5D" x="12786" y="0"></use>
</g>
</svg> e.g. A(j, 2^i) = A(A(j,2^(i - 1),2^(i-1)))</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeAncestor</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">TreeAncestor</span>(<span class="hljs-keyword">int</span> n, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; parent): <span class="hljs-built_in">g_</span>(n), <span class="hljs-built_in">a_</span>(n) &#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i)<br>			g_[parent[i]].<span class="hljs-built_in">push_back</span>(i);<br>		vector&lt;<span class="hljs-keyword">int</span>&gt; path;<br>		<span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, path);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getKthAncestor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> node, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>		<span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> node;<br>		<span class="hljs-keyword">if</span> (node == <span class="hljs-number">0</span> &amp;&amp; k &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    <br>		<span class="hljs-keyword">int</span> l = <span class="hljs-built_in">min</span>(<span class="hljs-number">31ul</span> - __builtin_clz(k), a_[node].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">getKthAncestor</span>(a_[node][l], k - (<span class="hljs-number">1</span> &lt;&lt; l));<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>	vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; g_, a_;  <br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> node, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; path)</span> </span>&#123;    <br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= path.<span class="hljs-built_in">size</span>(); i *= <span class="hljs-number">2</span>)<br>			a_[node].<span class="hljs-built_in">push_back</span>(path[path.<span class="hljs-built_in">size</span>() - i]);<br>		path.<span class="hljs-built_in">push_back</span>(node);<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> c : g_[node]) <span class="hljs-built_in">dfs</span>(c, path);<br>		path.<span class="hljs-built_in">pop_back</span>();    <br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your TreeAncestor object will be instantiated and called as such:</span><br><span class="hljs-comment"> * TreeAncestor* obj = new TreeAncestor(n, parent);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;getKthAncestor(node,k);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeAncestor</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">TreeAncestor</span>(<span class="hljs-keyword">int</span> n, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; parent): <span class="hljs-built_in">max_level_</span>(<span class="hljs-number">32</span> - __builtin_clz(n)), <span class="hljs-built_in">dp_</span>(max_level_, vector&lt;<span class="hljs-keyword">int</span>&gt;(n)) &#123;<br>        dp_[<span class="hljs-number">0</span>] = parent;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; max_level_; ++i)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j)<br>                dp_[i][j] = dp_[i - <span class="hljs-number">1</span>][j] == <span class="hljs-number">-1</span> ? <span class="hljs-number">-1</span> : dp_[i - <span class="hljs-number">1</span>][dp_[i - <span class="hljs-number">1</span>][j]];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getKthAncestor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> node, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; max_level_ &amp;&amp; node != <span class="hljs-number">-1</span>; ++i)<br>            <span class="hljs-keyword">if</span> (k &amp; (<span class="hljs-number">1</span> &lt;&lt; i))<br>                node = dp_[i][node];<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> max_level_;<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; dp_;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="1443-Minimum-Time-to-Collect-All-Apples-in-a-Tree-收集树上所有苹果的最小时间"><a href="#1443-Minimum-Time-to-Collect-All-Apples-in-a-Tree-收集树上所有苹果的最小时间" class="headerlink" title="1443. Minimum Time to Collect All Apples in a Tree(收集树上所有苹果的最小时间)"></a>1443. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-time-to-collect-all-apples-in-a-tree/">Minimum Time to Collect All Apples in a Tree(收集树上所有苹果的最小时间)</a></h2><h3 id="方法一：Recursion"><a href="#方法一：Recursion" class="headerlink" title="方法一：Recursion"></a>方法一：Recursion</h3><p>Min:</p>
<ul>
<li>No unnecessary nodes</li>
<li>visit each node at most once<br>A node needs to be visited if:</li>
</ul>
<ol>
<li>It has an apples</li>
<li>Any of its subtree has apple(s)<br>Build the graph for a N-ary tree<br>dfs(cur) = returns the min time for the tree rooted at cur.<br>dfs(cur) = sum(dfs(child) + 2 if case 1/2 else 0 for child in cur)</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; g, vector&lt;<span class="hljs-keyword">bool</span>&gt;&amp; hasApple)</span></span>&#123;<br>		<span class="hljs-keyword">int</span> total = <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> nxt : g[cur]) &#123;        <br>			<span class="hljs-keyword">int</span> cost = <span class="hljs-built_in">dfs</span>(nxt, g, hasApple);<br>			<span class="hljs-keyword">if</span> (cost &gt; <span class="hljs-number">0</span> || hasApple[nxt]) <br>				total += <span class="hljs-number">2</span> + cost;<br>		&#125; <br>		<span class="hljs-keyword">return</span> total;<br>	&#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minTime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; edges, vector&lt;<span class="hljs-keyword">bool</span>&gt;&amp; hasApple)</span> </span>&#123;<br>		vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">g</span>(n);<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; e : edges)<br>			g[e[<span class="hljs-number">0</span>]].<span class="hljs-built_in">push_back</span>(e[<span class="hljs-number">1</span>]); <br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, g, hasApple);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minTime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; edges, </span></span><br><span class="hljs-params"><span class="hljs-function">              vector&lt;<span class="hljs-keyword">bool</span>&gt;&amp; hasApple)</span> </span>&#123;<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">g</span>(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; e : edges) &#123;<br>      g[e[<span class="hljs-number">0</span>]].<span class="hljs-built_in">push_back</span>(e[<span class="hljs-number">1</span>]);<br>      g[e[<span class="hljs-number">1</span>]].<span class="hljs-built_in">push_back</span>(e[<span class="hljs-number">0</span>]);<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">seen</span><span class="hljs-params">(n)</span></span>;    <br>    function&lt;<span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(<span class="hljs-keyword">int</span>)&gt; dfs = [&amp;] (<span class="hljs-keyword">int</span> cur) &#123;<br>      seen[cur] = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">int</span> total = <span class="hljs-number">0</span>;      <br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> child : g[cur]) &#123;<br>        <span class="hljs-keyword">if</span> (seen[child]) <span class="hljs-keyword">continue</span>;        <br>        <span class="hljs-keyword">int</span> cost = <span class="hljs-built_in">dfs</span>(child);<br>        <span class="hljs-keyword">if</span> (cost &gt; <span class="hljs-number">0</span> || hasApple[child])          <br>          total += <span class="hljs-number">2</span> + cost;        <br>      &#125;      <br>      <span class="hljs-keyword">return</span> total;<br>    &#125;;    <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);    <br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="1382-Balance-a-Binary-Search-Tree-将二叉搜索树变平衡"><a href="#1382-Balance-a-Binary-Search-Tree-将二叉搜索树变平衡" class="headerlink" title="1382. Balance a Binary Search Tree(将二叉搜索树变平衡)"></a>1382. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/balance-a-binary-search-tree/">Balance a Binary Search Tree(将二叉搜索树变平衡)</a></h2><h3 id="方法一：Inorder-Recursion"><a href="#方法一：Inorder-Recursion" class="headerlink" title="方法一：Inorder + Recursion"></a>方法一：Inorder + Recursion</h3><p>Use inorder traversal to collect a sorted array from BST. And then build a balanced BST from this sorted array in O(n) time.<br>Time complexity: O(n)<br>Space complexity: O(n)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>	vector&lt;<span class="hljs-keyword">int</span>&gt; vals;<br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>		<span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;<br>		<span class="hljs-built_in">inorder</span>(root-&gt;left);<br>		vals.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>		<span class="hljs-built_in">inorder</span>(root-&gt;right);<br>	&#125;<br>	<span class="hljs-function">TreeNode* <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span>&#123;<br>		<span class="hljs-keyword">if</span> (l &gt; r) <span class="hljs-keyword">return</span> (TreeNode*)<span class="hljs-literal">nullptr</span>;<br>		<span class="hljs-keyword">int</span> m = l + (r - l) / <span class="hljs-number">2</span>;<br>		<span class="hljs-keyword">auto</span> root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(vals[m]);<br>		root-&gt;left = <span class="hljs-built_in">build</span>(l, m - <span class="hljs-number">1</span>);<br>		root-&gt;right = <span class="hljs-built_in">build</span>(m + <span class="hljs-number">1</span>, r);<br>		<span class="hljs-keyword">return</span> root;<br>	&#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">balanceBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>		<span class="hljs-built_in">inorder</span>(root);<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">build</span>(<span class="hljs-number">0</span>, vals.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="1373-Maximum-Sum-BST-in-Binary-Tree-二叉搜索子树的最大键值和"><a href="#1373-Maximum-Sum-BST-in-Binary-Tree-二叉搜索子树的最大键值和" class="headerlink" title="1373. Maximum Sum BST in Binary Tree(二叉搜索子树的最大键值和)"></a>1373. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-sum-bst-in-binary-tree/">Maximum Sum BST in Binary Tree(二叉搜索子树的最大键值和)</a></h2><h3 id="方法一：Recursion-1"><a href="#方法一：Recursion-1" class="headerlink" title="方法一：Recursion"></a>方法一：Recursion</h3><p>key question: when node is a BST?</p>
<ol>
<li>isBST(left) == True</li>
<li>isBST(right) == True</li>
<li>root.val &gt; max(left)</li>
<li>root.val &lt; min(right)</li>
</ol>
<p>for each node we return a tuple of:</p>
<ol start="5">
<li>minVal</li>
<li>maxVal</li>
<li>sum if its a BST (node.val + left.sum + right.sum)</li>
<li>whether its a BST<br>what is node is null ? return {min:+inf, max:inf, sum:0,isBST:True}</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSumBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>		<span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>		<span class="hljs-built_in">dfs</span>(root, &amp;ans);<br>		<span class="hljs-keyword">return</span> ans;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-function">tuple&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span>* ans)</span> </span>&#123;<br>		<span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> &#123;INT_MAX, INT_MIN, <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>&#125;;<br>		<span class="hljs-keyword">auto</span> [ll, lh, ls, lv] = <span class="hljs-built_in">dfs</span>(root-&gt;left, ans);<br>		<span class="hljs-keyword">auto</span> [rl, rh, rs, rv] = <span class="hljs-built_in">dfs</span>(root-&gt;right, ans);<br>		<span class="hljs-keyword">bool</span> valid = lv &amp;&amp; rv &amp;&amp; root-&gt;val &gt; lh &amp;&amp; root-&gt;val &lt; rl;    <br>		<span class="hljs-keyword">int</span> sum = valid ? ls + rs + root-&gt;val : <span class="hljs-number">-1</span>;<br>		*ans = <span class="hljs-built_in">max</span>(*ans, sum);<br>		<span class="hljs-keyword">return</span> &#123;<span class="hljs-built_in">min</span>(ll, root-&gt;val), <span class="hljs-built_in">max</span>(rh, root-&gt;val), sum, valid&#125;; <span class="hljs-comment">//考虑左右子树为空的情况</span><br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="108-Convert-Sorted-Array-to-Binary-Search-Tree-将有序数组转化为二叉搜索树"><a href="#108-Convert-Sorted-Array-to-Binary-Search-Tree-将有序数组转化为二叉搜索树" class="headerlink" title="108. Convert Sorted Array to Binary Search Tree(将有序数组转化为二叉搜索树)"></a>108. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/">Convert Sorted Array to Binary Search Tree(将有序数组转化为二叉搜索树)</a></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (l &gt; r)<br>            <span class="hljs-keyword">return</span> (TreeNode*) <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">auto</span> root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(nums[mid]);<br>        root-&gt;left = <span class="hljs-built_in">build</span>(l, mid - <span class="hljs-number">1</span>, nums);<br>        root-&gt;right = <span class="hljs-built_in">build</span>(mid + <span class="hljs-number">1</span>, r, nums);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> node = <span class="hljs-built_in">build</span>(<span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, nums);<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="1339-Maximum-Product-of-Splitted-Binary-Tree-分裂二叉树的最大乘积"><a href="#1339-Maximum-Product-of-Splitted-Binary-Tree-分裂二叉树的最大乘积" class="headerlink" title="1339. Maximum Product of Splitted Binary Tree(分裂二叉树的最大乘积)"></a>1339. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-product-of-splitted-binary-tree/">Maximum Product of Splitted Binary Tree(分裂二叉树的最大乘积)</a></h2><h3 id="方法一：Recursion-2"><a href="#方法一：Recursion-2" class="headerlink" title="方法一：Recursion"></a>方法一：Recursion</h3><p>Two passes:<br>First pass, compute the sum of the entire tree S.<br>Second pass, for each node, compute the sum of left/right subtree S_l, S_r.<br>ans = max{(S – S_l) * S_l, (S – S_r) * S_r}</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>: <br>    <span class="hljs-keyword">long</span> ans = <span class="hljs-number">0</span>;<br>	<span class="hljs-comment">//求整个树的和sum1</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> root-&gt;val + <span class="hljs-built_in">sum</span>(root-&gt;left) + <span class="hljs-built_in">sum</span>(root-&gt;right);<br>    &#125;<br><br>	<span class="hljs-comment">//求左右子树的和，将左子树的和 和 整个树的和 - 左子树的和 相乘， 右子树同理</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">long</span> sum1)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-built_in">solve</span>(root-&gt;left, sum1);<br>        <span class="hljs-keyword">int</span> right = <span class="hljs-built_in">solve</span>(root-&gt;right, sum1);<br>        ans = <span class="hljs-built_in">max</span>(&#123;ans, (sum1 - left) * left, (sum1 - right) * right&#125;);<br>        <span class="hljs-keyword">return</span> root-&gt;val + left + right;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> kMod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>        <span class="hljs-keyword">long</span> sum1 = <span class="hljs-built_in">sum</span>(root);<br>        <span class="hljs-built_in">solve</span>(root, sum1);<br>        <span class="hljs-keyword">return</span> ans % kMod;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="1305-All-Elements-in-Two-Binary-Search-Trees-两个二叉搜索树中的所有元素"><a href="#1305-All-Elements-in-Two-Binary-Search-Trees-两个二叉搜索树中的所有元素" class="headerlink" title="1305. All Elements in Two Binary Search Trees(两个二叉搜索树中的所有元素)"></a>1305. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problemset/all/?search=1305">All Elements in Two Binary Search Trees(两个二叉搜索树中的所有元素)</a></h2><h3 id="方法一：Inorder-traversal-Merge"><a href="#方法一：Inorder-traversal-Merge" class="headerlink" title="方法一：Inorder traversal + Merge"></a>方法一：Inorder traversal + Merge</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; nums1;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; nums2;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preorder</span><span class="hljs-params">(TreeNode* root, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">preorder</span>(root-&gt;left, nums);<br>        nums.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">preorder</span>(root-&gt;right, nums);<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">getAllElements</span><span class="hljs-params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;<br>        <span class="hljs-built_in">preorder</span>(root1, nums1);<br>        <span class="hljs-built_in">preorder</span>(root2, nums2);<br>        <span class="hljs-keyword">int</span> point1 = <span class="hljs-number">0</span>, point2 = <span class="hljs-number">0</span>;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>        <span class="hljs-keyword">while</span> (point1 &lt; nums1.<span class="hljs-built_in">size</span>() &amp;&amp; point2 &lt; nums2.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-keyword">if</span> (nums1[point1] &lt; nums2[point2])<br>                ans.<span class="hljs-built_in">emplace_back</span>(nums1[point1++]);<br>            <span class="hljs-keyword">else</span><br>                ans.<span class="hljs-built_in">emplace_back</span>(nums2[point2++]);<br>        &#125;<br>        <span class="hljs-keyword">while</span> (point1 &lt; nums1.<span class="hljs-built_in">size</span>())&#123;<br>            ans.<span class="hljs-built_in">emplace_back</span>(nums1[point1++]);<br>        &#125;<br>        <span class="hljs-keyword">while</span> (point2 &lt; nums2.<span class="hljs-built_in">size</span>())&#123;<br>            ans.<span class="hljs-built_in">emplace_back</span>(nums2[point2++]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="1296-Divide-Array-in-Sets-of-K-Consecutive-Numbers-划分数组为连续数字的集合"><a href="#1296-Divide-Array-in-Sets-of-K-Consecutive-Numbers-划分数组为连续数字的集合" class="headerlink" title="1296. Divide Array in Sets of K Consecutive Numbers(划分数组为连续数字的集合)"></a>1296. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/divide-array-in-sets-of-k-consecutive-numbers/">Divide Array in Sets of K Consecutive Numbers(划分数组为连续数字的集合)</a></h2><h3 id="方法一：Greedy-Map"><a href="#方法一：Greedy-Map" class="headerlink" title="方法一：Greedy + Map"></a>方法一：Greedy + Map</h3><p>start with the smallest number and find k consecutive numbers. If anyone is missing then there is no answer</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPossibleDivide</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; frequency;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums)<br>            frequency[num]++;<br>        map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;::iterator iter;<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (frequency.<span class="hljs-built_in">empty</span>() == <span class="hljs-literal">false</span>) &#123;<br>            iter = frequency.<span class="hljs-built_in">begin</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>                <span class="hljs-keyword">if</span> (frequency.<span class="hljs-built_in">count</span>(iter-&gt;first + i) == <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">int</span> temp = iter-&gt;first;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>                frequency[temp + i]--;<br>                <span class="hljs-keyword">if</span> (frequency[temp + i] == <span class="hljs-number">0</span>) &#123;<br>                    frequency.<span class="hljs-built_in">erase</span>(temp + i);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="方法二：HashTable-starts"><a href="#方法二：HashTable-starts" class="headerlink" title="方法二：HashTable + starts"></a>方法二：HashTable + starts</h3><p>use hashtable to store the frequencie of each number<br>use a queue(starts) to track the first element of each sequence<br>condition:<br>f[i] &gt; 0 &amp;&amp; f[i - 1] == 0, i is the start<br>for each start s, f[s+k] -= f[s], 0 &lt;= k &lt; K<br>if f[s+k] == 0 &amp;&amp; f[s+k+1] &gt; 0, s+k+1 becomes a start</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPossibleDivide</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>		<span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() % k != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br>        unordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; frequency;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums)<br>            frequency[num]++;<br>		queue&lt;<span class="hljs-keyword">int</span>&gt; starts;<br>		<span class="hljs-keyword">for</span> (pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; item : frequency)&#123;<br>			<span class="hljs-keyword">if</span>(frequency.<span class="hljs-built_in">count</span>(item.first - <span class="hljs-number">1</span>))<br>				starts.<span class="hljs-built_in">push</span>(item.first);<br>		&#125;<br>		<span class="hljs-keyword">while</span> (!starts.<span class="hljs-built_in">empty</span>())&#123;<br>			<span class="hljs-keyword">int</span> s = starts.<span class="hljs-built_in">front</span>();<br>			starts.<span class="hljs-built_in">pop</span>();<br>			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = s + k - <span class="hljs-number">1</span>; i &gt;= s; i--)&#123;<br>				<span class="hljs-keyword">if</span>(frequency[i] &lt; frequency[s]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>				<span class="hljs-keyword">if</span> ((f[i] -= f[s]) == <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">//index 为 i 的元素都被用完</span><br>					frequency.<span class="hljs-built_in">erase</span>(i);<br>					<span class="hljs-keyword">if</span> (f.<span class="hljs-built_in">count</span>(i + <span class="hljs-number">1</span>))<br>						starts.<span class="hljs-built_in">push</span>(i + <span class="hljs-number">1</span>);<br>				&#125;<br>			&#125;<br>		&#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="116-Populating-Next-Right-Pointers-in-Each-Nod-填充每个节点的下一个右侧节点指针"><a href="#116-Populating-Next-Right-Pointers-in-Each-Nod-填充每个节点的下一个右侧节点指针" class="headerlink" title="116. Populating Next Right Pointers in Each Nod(填充每个节点的下一个右侧节点指针)"></a>116. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/">Populating Next Right Pointers in Each Nod(填充每个节点的下一个右侧节点指针)</a></h2><h3 id="方法一：层序遍历"><a href="#方法一：层序遍历" class="headerlink" title="方法一：层序遍历"></a>方法一：层序遍历</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">connect</span><span class="hljs-params">(Node* root)</span> </span>&#123;<br>		queue&lt;Node*&gt; queue;<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">nullptr</span>)<br>            queue.<span class="hljs-built_in">push</span>(root);<br>		<span class="hljs-keyword">while</span>(!queue.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">int</span> size = queue.<span class="hljs-built_in">size</span>();<br>            vector&lt;Node*&gt; vec_level;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; size;i ++)&#123;<br>                Node* node = queue.<span class="hljs-built_in">front</span>();<br>                queue.<span class="hljs-built_in">pop</span>();<br>                vec_level.<span class="hljs-built_in">push_back</span>(node);<br>                <span class="hljs-keyword">if</span>(node-&gt;left)<br>                    queue.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span>(node-&gt;right)<br>                    queue.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; vec_level.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;i ++)&#123;<br>                Node* node = vec_level[i];<br>                node-&gt;next = vec_level[i+<span class="hljs-number">1</span>];<br>            &#125;     <br>        &#125;<br>		<span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="方法二：Recursion-Pre-Order"><a href="#方法二：Recursion-Pre-Order" class="headerlink" title="方法二：Recursion + Pre_Order"></a>方法二：Recursion + Pre_Order</h3><p>cur.left.next = cur.right<br>cur.right.next = cur.next.left</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">connect</span><span class="hljs-params">(Node* root)</span> </span>&#123;<br>		<span class="hljs-keyword">if</span> (!root || !root-&gt;left) <span class="hljs-keyword">return</span> root;<br>		root-&gt;left-&gt;next = root-&gt;right;<br>		<span class="hljs-keyword">if</span>(root-&gt;next)<br>			root-&gt;right-&gt;next = root-&gt;next-&gt;left;<br>		<span class="hljs-built_in">connect</span>(root-&gt;left);<br>		<span class="hljs-built_in">connect</span>(root-&gt;right);<br>		<span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="1110-Delete-Nodes-And-Return-Forest-删点成林"><a href="#1110-Delete-Nodes-And-Return-Forest-删点成林" class="headerlink" title="1110. Delete Nodes And Return Forest(删点成林)"></a>1110. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/delete-nodes-and-return-forest/">Delete Nodes And Return Forest(删点成林)</a></h2><h3 id="方法一：Recursion-3"><a href="#方法一：Recursion-3" class="headerlink" title="方法一：Recursion"></a>方法一：Recursion</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span> <br><span class="hljs-keyword">private</span>:<br>	vector&lt;TreeNode*&gt; ans;<br>	<span class="hljs-function">TreeNode* <span class="hljs-title">process</span><span class="hljs-params">(TreeNode* cur)</span></span>&#123;<br>		<span class="hljs-keyword">if</span> (!cur) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>		cur-&gt;left = <span class="hljs-built_in">process</span>(cur-&gt;left);<br>		cur-&gt;right = <span class="hljs-built_in">process</span>(cur-&gt;right);<br>		<span class="hljs-keyword">if</span> (to_delete.<span class="hljs-built_in">count</span>(cur-&gt;val) == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> cur;<br>		<span class="hljs-keyword">if</span> (cur-&gt;left) ans.<span class="hljs-built_in">push_back</span>(cur-&gt;left)<br>		<span class="hljs-keyword">if</span> (cur-&gt;right) ans.<span class="hljs-built_in">push_back</span>(cur-&gt;right);<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>	&#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;TreeNode*&gt; <span class="hljs-title">delNodes</span><span class="hljs-params">(TreeNode* root, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; to_delete)</span> </span>&#123;<br>        root = <span class="hljs-built_in">process</span>(root);<br>		<span class="hljs-keyword">if</span> (root)<br>			ans.<span class="hljs-built_in">push_back</span>(root);<br>		<span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="1145-Binary-Tree-Coloring-Game-二叉树着色游戏"><a href="#1145-Binary-Tree-Coloring-Game-二叉树着色游戏" class="headerlink" title="1145. Binary Tree Coloring Game(二叉树着色游戏)"></a>1145. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-coloring-game/">Binary Tree Coloring Game(二叉树着色游戏)</a></h2><p>蓝色节点的放置位置是在红色节点的父结点，左孩子结点、右孩子结点之间的一个<br>Left : size(L)<br>Right: size(R)<br>Parent: n - size(L) - size(R) - 1<br>Win if any of above has size &gt; n/2</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">btreeGameWinningMove</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>		<span class="hljs-built_in">nodes</span>(root,x);<br>		<span class="hljs-keyword">int</span> p = n - (<span class="hljs-number">1</span> + l_ + r_); <span class="hljs-comment">//总节点数 - （红色节点 + 红色节点的左子树节点 + 红色节点的右子树节点）</span><br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(p,<span class="hljs-built_in">max</span>(l_,r_)) &gt; n/<span class="hljs-number">2</span>;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-keyword">int</span> l_; <span class="hljs-comment">//左节点的数量</span><br>	<span class="hljs-keyword">int</span> r_; <span class="hljs-comment">//右节点的数量</span><br>	<span class="hljs-comment">//求红色节点的左子树的节点数目 以及  右子树的节点数目</span><br>	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">nodes</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> x)</span></span>&#123;<br>		<span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">int</span> l = <span class="hljs-built_in">nodes</span>(root-&gt;left, x);<br>		<span class="hljs-keyword">int</span> r = <span class="hljs-built_in">nodes</span>(root-&gt;right,x);<br>		<span class="hljs-keyword">if</span> (root-&gt;val == x)&#123;<br>			l_ = l;<br>			r_ = r;<br>		&#125;<br>		<span class="hljs-keyword">return</span> l + r + <span class="hljs-number">1</span>;<br>	&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="979-Distribute-Coins-in-Binary-Tree-在二叉树中分配硬币"><a href="#979-Distribute-Coins-in-Binary-Tree-在二叉树中分配硬币" class="headerlink" title="979. Distribute Coins in Binary Tree(在二叉树中分配硬币)"></a>979. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/distribute-coins-in-binary-tree/">Distribute Coins in Binary Tree(在二叉树中分配硬币)</a></h2><h3 id="方法一：Recursion-4"><a href="#方法一：Recursion-4" class="headerlink" title="方法一：Recursion"></a>方法一：Recursion</h3><p>Root: make children balanced<br>balance(root) = v - 1 + balance(left) + balance(right)<br>flow(l) = abs(balance(left))<br>flow(r) = abs(balance(right))<br>ans += flow(l) + flow(r)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">distributeCoins</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>		<span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>		<span class="hljs-built_in">balance</span>(root, ans);<br>		<span class="hljs-keyword">return</span> ans;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">balance</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span>&amp; ans)</span></span>&#123;<br>		<span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">int</span> left = <span class="hljs-built_in">balance</span>(root-&gt;left, ans);<br>		<span class="hljs-keyword">int</span> right = <span class="hljs-built_in">balance</span>(root-&gt;right, ans);<br>		ans += <span class="hljs-built_in">abs</span>(left) + <span class="hljs-built_in">abs</span>(right);<br>		<span class="hljs-keyword">return</span> root-&gt;val - <span class="hljs-number">1</span> + left + right;<br>	&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="894-All-Possible-Full-Binary-Trees-所有可能的满二叉树"><a href="#894-All-Possible-Full-Binary-Trees-所有可能的满二叉树" class="headerlink" title="894. All Possible Full Binary Trees(所有可能的满二叉树)"></a>894. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/all-possible-full-binary-trees/">All Possible Full Binary Trees(所有可能的满二叉树)</a></h2><h3 id="方法一：Recursion-DP"><a href="#方法一：Recursion-DP" class="headerlink" title="方法一：Recursion/DP"></a>方法一：Recursion/DP</h3><p>满二叉树是一类二叉树，其中每个结点恰好有 0 或 2 个子结点。<br>Key observation:</p>
<ol>
<li># of nodes is always odd.</li>
<li>Subtrees are solutions from smaller problems.<br>trees(n):<br>for i = 1 to n, step 2:<br>root.left = trees(i)<br>root.right = trees(n - i - 1)</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;TreeNode*&gt; <span class="hljs-title">allPossibleFBT</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>		<span class="hljs-keyword">if</span>(n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> &#123;&#125;;<br>		<span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> &#123;<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">0</span>)&#125;;<br>		vector&lt;TreeNode*&gt; ans;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i = i + <span class="hljs-number">2</span>)&#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> l : <span class="hljs-built_in">allPossibleFBT</span>(i))&#123;<br>				<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> r : <span class="hljs-built_in">allPossibleFBT</span>(n - i - <span class="hljs-number">1</span>))&#123;<br>					<span class="hljs-keyword">auto</span> root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">0</span>);<br>					root-&gt;left = l;<br>					root-&gt;right = r;<br>					ans.<span class="hljs-built_in">push_back</span>(root);<br>				&#125;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a>105. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">从前序与中序遍历序列构造二叉树</a></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">traversal</span> <span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; inorder, <span class="hljs-keyword">int</span> inorderBegin, <span class="hljs-keyword">int</span> inorderEnd, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; preorder, <span class="hljs-keyword">int</span> preorderBegin, <span class="hljs-keyword">int</span> preorderEnd)</span> </span>&#123;<br>        <span class="hljs-comment">//前序遍历序列为空</span><br>        <span class="hljs-keyword">if</span> (preorderBegin == preorderEnd)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <br>        <span class="hljs-comment">//取出中间节点</span><br>        <span class="hljs-keyword">int</span> rootValue = preorder[preorderBegin];<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(rootValue);<br><br>        <span class="hljs-comment">//叶子结点</span><br>        <span class="hljs-keyword">if</span>(preorderEnd - preorderBegin == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> root;<br><br>        <span class="hljs-comment">//在中序遍历序列中找到切割点</span><br>        <span class="hljs-keyword">int</span> delimiterIndex;<br>        <span class="hljs-keyword">for</span>(delimiterIndex = inorderBegin;delimiterIndex &lt; inorderEnd;delimiterIndex++)&#123;<br>            <span class="hljs-keyword">if</span>(inorder[delimiterIndex] == rootValue)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">//切割中序遍历序列，得到中序左数组和中序右数组</span><br>        <span class="hljs-keyword">int</span> leftInorderBegin = inorderBegin;<br>        <span class="hljs-keyword">int</span> leftInorderEnd = delimiterIndex;<br>        <span class="hljs-keyword">int</span> rightInorderBegin = delimiterIndex + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> rightInorderEnd = inorderEnd;<br><br>        <span class="hljs-comment">//切割前序遍历序列，得到后序左数组和后序右数组</span><br><br>        <span class="hljs-keyword">int</span> leftPreorderBegin = preorderBegin + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> leftPreorderEnd = preorderBegin + <span class="hljs-number">1</span> + leftInorderEnd - leftInorderBegin;<br>        <span class="hljs-keyword">int</span> rightPreorderBegin = preorderBegin + <span class="hljs-number">1</span> + leftInorderEnd - leftInorderBegin;<br>        <span class="hljs-keyword">int</span> rightPreorderEnd = preorderEnd;<br><br>        root-&gt;left = <span class="hljs-built_in">traversal</span>(inorder,leftInorderBegin,leftInorderEnd,preorder,leftPreorderBegin,leftPreorderEnd);<br>        root-&gt;right = <span class="hljs-built_in">traversal</span>(inorder,rightInorderBegin,rightInorderEnd,preorder,rightPreorderBegin,rightPreorderEnd);<br><br>        <span class="hljs-keyword">return</span> root;<br><br><br>    &#125;<br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (inorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> || preorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">traversal</span>(inorder, <span class="hljs-number">0</span>,inorder.<span class="hljs-built_in">size</span>(),preorder,<span class="hljs-number">0</span>,preorder.<span class="hljs-built_in">size</span>());<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a>106. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">从中序与后序遍历序列构造二叉树</a></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">traversal</span> <span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; inorder, <span class="hljs-keyword">int</span> inorderBegin, <span class="hljs-keyword">int</span> inorderEnd, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; postorder, <span class="hljs-keyword">int</span> postorderBegin, <span class="hljs-keyword">int</span> postorderEnd)</span> </span>&#123;<br>        <span class="hljs-comment">//后序遍历序列为空</span><br>        <span class="hljs-keyword">if</span> (postorderBegin == postorderEnd)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <br>        <span class="hljs-comment">//取出中间节点</span><br>        <span class="hljs-keyword">int</span> rootValue = postorder[postorderEnd<span class="hljs-number">-1</span>];<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(rootValue);<br><br>        <span class="hljs-comment">//叶子结点</span><br>        <span class="hljs-keyword">if</span>(postorderEnd - postorderBegin == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> root;<br><br>        <span class="hljs-comment">//在中序遍历序列中找到切割点</span><br>        <span class="hljs-keyword">int</span> delimiterIndex;<br>        <span class="hljs-keyword">for</span>(delimiterIndex = inorderBegin;delimiterIndex &lt; inorderEnd;delimiterIndex++)&#123;<br>            <span class="hljs-keyword">if</span>(inorder[delimiterIndex] == rootValue)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">//切割中序遍历序列，得到中序左数组和中序右数组</span><br>        <span class="hljs-keyword">int</span> leftInorderBegin = inorderBegin;<br>        <span class="hljs-keyword">int</span> leftInorderEnd = delimiterIndex;<br>        <span class="hljs-keyword">int</span> rightInorderBegin = delimiterIndex + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> rightInorderEnd = inorderEnd;<br><br>        <span class="hljs-comment">//切割后序遍历序列，得到后序左数组和后序右数组</span><br><br>        <span class="hljs-keyword">int</span> leftPostorderBegin = postorderBegin;<br>        <span class="hljs-keyword">int</span> leftPostorderEnd = postorderBegin + leftInorderEnd - leftInorderBegin;<br>        <span class="hljs-keyword">int</span> rightPostorderBegin = postorderBegin + leftInorderEnd - leftInorderBegin;<br>        <span class="hljs-keyword">int</span> rightPostorderEnd = postorderEnd - <span class="hljs-number">1</span>;<br><br>        root-&gt;left = <span class="hljs-built_in">traversal</span>(inorder,leftInorderBegin,leftInorderEnd,postorder,leftPostorderBegin,leftPostorderEnd);<br>        root-&gt;right = <span class="hljs-built_in">traversal</span>(inorder,rightInorderBegin,rightInorderEnd,postorder,rightPostorderBegin,rightPostorderEnd);<br><br>        <span class="hljs-keyword">return</span> root;<br><br><br>    &#125;<br>    <br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (inorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> || postorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">traversal</span>(inorder, <span class="hljs-number">0</span>,inorder.<span class="hljs-built_in">size</span>(),postorder,<span class="hljs-number">0</span>,postorder.<span class="hljs-built_in">size</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">traversal</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; postorder)</span></span>&#123;<br>        <span class="hljs-comment">//后序遍历序列为空</span><br>        <span class="hljs-keyword">if</span>(postorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <br>        <span class="hljs-comment">//取出中间节点</span><br>        <span class="hljs-keyword">int</span> rootValue = postorder[postorder.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>];<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(rootValue);<br><br>        <span class="hljs-comment">//叶子结点</span><br>        <span class="hljs-keyword">if</span>(postorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> root;<br><br>        <span class="hljs-comment">//在中序遍历序列中找到切割点</span><br>        <span class="hljs-keyword">int</span> delimiterIndex;<br>        <span class="hljs-keyword">for</span>(delimiterIndex = <span class="hljs-number">0</span>;delimiterIndex &lt; inorder.<span class="hljs-built_in">size</span>();delimiterIndex++)&#123;<br>            <span class="hljs-keyword">if</span>(inorder[delimiterIndex] == rootValue)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">//切割中序遍历序列，得到中序左数组和中序右数组</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">leftInorder</span><span class="hljs-params">(inorder.begin(), inorder.begin() + delimiterIndex)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">rightInorder</span><span class="hljs-params">(inorder.begin() + delimiterIndex + <span class="hljs-number">1</span>, inorder.end() )</span></span>;<br><br>        <span class="hljs-comment">//切割后序遍历序列，得到后序左数组和后序右数组</span><br>        postorder.<span class="hljs-built_in">resize</span>(postorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">leftPostorder</span><span class="hljs-params">(postorder.begin(), postorder.begin() + leftInorder.size())</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">rightPostorder</span><span class="hljs-params">(postorder.begin() + leftInorder.size(), postorder.end())</span></span>;<br><br>        root-&gt;left = <span class="hljs-built_in">traversal</span>(leftInorder,leftPostorder);<br>        root-&gt;right = <span class="hljs-built_in">traversal</span>(rightInorder,rightPostorder);<br><br>        <span class="hljs-keyword">return</span> root;<br><br><br>    &#125;<br>    <br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (inorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> || postorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">traversal</span>(inorder, postorder);<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>



<h2 id="889-Construct-Binary-Tree-from-Preorder-and-Postorder-Traversal-根据前序和后序遍历构造二叉树"><a href="#889-Construct-Binary-Tree-from-Preorder-and-Postorder-Traversal-根据前序和后序遍历构造二叉树" class="headerlink" title="889. Construct Binary Tree from Preorder and Postorder Traversal(根据前序和后序遍历构造二叉树)"></a>889. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/">Construct Binary Tree from Preorder and Postorder Traversal(根据前序和后序遍历构造二叉树)</a></h2><h3 id="方法一：Recursion-5"><a href="#方法一：Recursion-5" class="headerlink" title="方法一：Recursion"></a>方法一：Recursion</h3><p>pre = [(root) (left-child) (right-child)]<br>post = [(left-child) (right-child) (root)]<br>We need to recursively find the first node in pre.left-child from post.left-child</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">constructFromPrePost</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; pre, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; post)</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">constructFromPrePost</span>(<span class="hljs-built_in">cbegin</span>(pre), <span class="hljs-built_in">cend</span>(pre), <span class="hljs-built_in">cbegin</span>(post), <span class="hljs-built_in">cend</span>(post));<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-keyword">typedef</span> vector&lt;<span class="hljs-keyword">int</span>&gt;::const_iterator VIT;<br>	<span class="hljs-function">TreeNode* <span class="hljs-title">constructFromPrePost</span><span class="hljs-params">(VIT pre_l, VIT pre_r, VIT post_l, VIT post_r)</span> </span>&#123;<br>		<span class="hljs-keyword">if</span> (pre_l == pre_r) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>		TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(*pre_l);<br>		++pre_l;<br>		--post_r;<br>		<span class="hljs-keyword">if</span> (pre_l == pre_r) <span class="hljs-keyword">return</span> root;<br>		VIT post_m = <span class="hljs-built_in">next</span>(<span class="hljs-built_in">find</span>(post_l, post_r, *pre_l));<br>		VIT pre_m = pre_l + (post_m - post_l);<br>		root-&gt;left = <span class="hljs-built_in">constructFromPrePost</span>(pre_l, pre_m, post_l, post_m);<br>		root-&gt;right = <span class="hljs-built_in">constructFromPrePost</span>(pre_m, pre_r, post_m, post_r);<br>		<span class="hljs-keyword">return</span> root;<br>	&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="865-Smallest-Subtree-with-all-the-Deepest-Nodes-具有所有最深节点的最小子树"><a href="#865-Smallest-Subtree-with-all-the-Deepest-Nodes-具有所有最深节点的最小子树" class="headerlink" title="865. Smallest Subtree with all the Deepest Nodes(具有所有最深节点的最小子树)"></a>865. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/smallest-subtree-with-all-the-deepest-nodes/">Smallest Subtree with all the Deepest Nodes(具有所有最深节点的最小子树)</a></h2><h3 id="方法一：Recursion-6"><a href="#方法一：Recursion-6" class="headerlink" title="方法一：Recursion"></a>方法一：Recursion</h3><p>compare the depth of children<br>case 1: same depth return root<br>case 2: dl &gt; dr return ans of root-&gt;left<br>case 3: dl &lt; dr return ans of root-&gt;right<br>return a pair{当前节点的深度, 当前最好解}</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">subtreeWithAllDeepest</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">depth</span>(root).second;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-function">pair&lt;<span class="hljs-keyword">int</span>,TreeNode*&gt; <span class="hljs-title">depth</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>		<span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">-1</span>, <span class="hljs-literal">nullptr</span>&#125;;<br>		pair&lt;<span class="hljs-keyword">int</span>,TreeNode*&gt; l = <span class="hljs-built_in">depth</span>(root-&gt;left);<br>		pair&lt;<span class="hljs-keyword">int</span>,TreeNode*&gt; r = <span class="hljs-built_in">depth</span>(root-&gt;right);<br>		TreeNode* best = l.first == r.first ? root : (l.first &gt; r.first) ? l.second : r.second;<br>		<span class="hljs-keyword">return</span> &#123;<span class="hljs-built_in">max</span>(l.first, r.first) + <span class="hljs-number">1</span>, best&#125;;<br>	&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="863-All-Nodes-Distance-K-in-Binary-Tree-二叉树中所有距离为K的节点"><a href="#863-All-Nodes-Distance-K-in-Binary-Tree-二叉树中所有距离为K的节点" class="headerlink" title="863. All Nodes Distance K in Binary Tree(二叉树中所有距离为K的节点)"></a>863. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree/">All Nodes Distance K in Binary Tree(二叉树中所有距离为K的节点)</a></h2><h3 id="方法一：Build-Graph-BFS"><a href="#方法一：Build-Graph-BFS" class="headerlink" title="方法一：Build Graph + BFS"></a>方法一：Build Graph + BFS</h3><ol>
<li>Build a undirected graph from the tree</li>
<li>Traverse the graph from target</li>
<li>Collect all nodes that are K steps from target</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">distanceK</span><span class="hljs-params">(TreeNode* root, TreeNode* target, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>		<span class="hljs-built_in">buildGraph</span>(<span class="hljs-literal">nullptr</span>, root);<br>		vector&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>		unordered_set&lt;TreeNode*&gt; seen;<br>		queue&lt;TreeNode*&gt; q;<br>		seen.<span class="hljs-built_in">insert</span>(target);<br>		q.<span class="hljs-built_in">push</span>(target);<br>		<span class="hljs-keyword">int</span> distance = <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; distance &lt;= k)&#123;<br>			<span class="hljs-keyword">int</span> s = q.<span class="hljs-built_in">size</span>();<br>			<span class="hljs-keyword">while</span> (s--)&#123;<br>				TreeNode* node = q.<span class="hljs-built_in">front</span>();<br>				q.<span class="hljs-built_in">pop</span>();<br>				<span class="hljs-keyword">if</span> (distance == k) ans.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>				<span class="hljs-keyword">for</span> (TreeNode* child : g[node])&#123;<br>					<span class="hljs-keyword">if</span> (seen.<span class="hljs-built_in">count</span>(child) != <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>					seen.<span class="hljs-built_in">insert</span>(child);<br>					q.<span class="hljs-built_in">push</span>(child);<br>				&#125;<br>			&#125;<br>			distance++;<br>		&#125;<br>		<span class="hljs-keyword">return</span> ans;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>	unordered_map&lt;TreeNode*, vector&lt;TreeNode*&gt;&gt; g;<br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildGraph</span><span class="hljs-params">(TreeNode* parent, TreeNode* child)</span></span>&#123;<br>		<span class="hljs-keyword">if</span>(parent)&#123;<br>			g[parent].<span class="hljs-built_in">push_back</span>(child);<br>			g[child].<span class="hljs-built_in">push_back</span>(parent);<br>		&#125;<br>		<span class="hljs-keyword">if</span> (child-&gt;left) <span class="hljs-built_in">buildGraph</span>(child, child-&gt;left);<br>		<span class="hljs-keyword">if</span> (child-&gt;right) <span class="hljs-built_in">buildGraph</span>(child, child-&gt;right);<br>	&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="方法二：-Recursion"><a href="#方法二：-Recursion" class="headerlink" title="方法二： Recursion"></a>方法二： Recursion</h3><ol>
<li>Compute the distance from root to target</li>
<li>Collect nodes based on the distance<br>a. itself<br>b. nodes in the subtree that does not contain target</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">distanceK</span><span class="hljs-params">(TreeNode* root, TreeNode* target, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>		ans.<span class="hljs-built_in">clear</span>();<br>		<span class="hljs-built_in">dis</span>(root, target, k);<br>		<span class="hljs-keyword">return</span> ans;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>	vector&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>	<span class="hljs-comment">// Returns the distance from root to target.</span><br>	<span class="hljs-comment">// Returns -1 if target does not in the tree.</span><br>	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dis</span><span class="hljs-params">(TreeNode* root, TreeNode* target, <span class="hljs-keyword">int</span> K)</span> </span>&#123;<br>		<span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>		<span class="hljs-keyword">if</span> (root == target) &#123;<br>			<span class="hljs-built_in">collect</span>(target, K);<br>			<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>		&#125;<br>    <br>		<span class="hljs-keyword">int</span> l = <span class="hljs-built_in">dis</span>(root-&gt;left, target, K);<br>		<span class="hljs-keyword">int</span> r = <span class="hljs-built_in">dis</span>(root-&gt;right, target, K);<br>    <br>		<span class="hljs-comment">// Target in the left subtree</span><br>		<span class="hljs-keyword">if</span> (l &gt;= <span class="hljs-number">0</span>) &#123;<br>			<span class="hljs-keyword">if</span> (l == K - <span class="hljs-number">1</span>) ans.<span class="hljs-built_in">push_back</span>(root-&gt;val); <span class="hljs-comment">//root到target正好是K步</span><br>			<span class="hljs-comment">// Collect nodes in right subtree with depth K - l - 2</span><br>			<span class="hljs-built_in">collect</span>(root-&gt;right, K - l - <span class="hljs-number">2</span>); <span class="hljs-comment">//收集右子树的node</span><br>			<span class="hljs-keyword">return</span> l + <span class="hljs-number">1</span>;<br>		&#125;<br>    <br>		<span class="hljs-comment">// Target in the right subtree</span><br>		<span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;<br>			<span class="hljs-keyword">if</span> (r == K - <span class="hljs-number">1</span>) ans.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>			<span class="hljs-comment">// Collect nodes in left subtree with depth K - r - 2</span><br>			<span class="hljs-built_in">collect</span>(root-&gt;left, K - r - <span class="hljs-number">2</span>);<br>			<span class="hljs-keyword">return</span> r + <span class="hljs-number">1</span>;<br>		&#125;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>	&#125;<br>	<span class="hljs-comment">// Collect nodes that are d steps from root.</span><br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">collect</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> d)</span> </span>&#123;<br>		<span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span> || d &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>		<span class="hljs-keyword">if</span> (d == <span class="hljs-number">0</span>) ans.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>		<span class="hljs-built_in">collect</span>(root-&gt;left, d - <span class="hljs-number">1</span>);<br>		<span class="hljs-built_in">collect</span>(root-&gt;right, d - <span class="hljs-number">1</span>);<br>	&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="823-Binary-Trees-With-Factors-带因子的二叉树"><a href="#823-Binary-Trees-With-Factors-带因子的二叉树" class="headerlink" title="823. Binary Trees With Factors(带因子的二叉树)"></a>823. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-trees-with-factors/">Binary Trees With Factors(带因子的二叉树)</a></h2><h3 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h3><p>Use dp[i] to denote the number of valid binary trees using the first i + 1 smallest elements and roots at A[i].<br>dp[i] = sum(dp[j] * dp[i/j]),  0 &lt;= j &lt; i, A[i] is a factor of A[j] and A[i] / A[j] also in A.<br>dp[8] = dp[2] * dp[4] + dp[4] * dp[2]<br>dp[4] = dp[2] * dp[2]<br>ans = sum(dp[i]) i in arr</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numFactoredBinaryTrees</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr)</span> </span>&#123;<br>		<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">long</span> kMod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>		<span class="hljs-built_in">sort</span>(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>());<br>		unordered_map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">long</span>&gt; dp;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">size</span>(); i++)&#123;<br>			dp[arr[i]] = <span class="hljs-number">1</span>;<br>			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)&#123;<br>				<span class="hljs-keyword">if</span>(arr[i] % arr[j] == <span class="hljs-number">0</span> &amp;&amp; dp.<span class="hljs-built_in">count</span>(arr[i]/arr[j]))<br>					dp[arr[i]] += (dp[arr[j]] * dp[arr[i]/arr[j]]) % kMod;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">long</span> ans = <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; item : dp)&#123;<br>			ans += item.second;<br>		&#125;<br>		<span class="hljs-keyword">return</span> ans % kMod;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="486-Predict-the-Winner-预测赢家"><a href="#486-Predict-the-Winner-预测赢家" class="headerlink" title="486. Predict the Winner(预测赢家)"></a>486. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/predict-the-winner/">Predict the Winner(预测赢家)</a></h2><h3 id="方法一：Recursion-Memorization"><a href="#方法一：Recursion-Memorization" class="headerlink" title="方法一：Recursion + Memorization"></a>方法一：Recursion + Memorization</h3><p>Min-Max Strategy:<br>always pick the best, and your opponent eill do the same thing!<br>No Memory: TC: T(n) = 2T(n - 1) + O(1)<br>With Memory:<br>use dp(i,j) to store the best score that current player can achieve</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">PredictTheWinner</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">getScore</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &gt;= <span class="hljs-number">0</span>;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getScore</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span>&#123;<br>		<span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span> nums[l];<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(nums[l] - <span class="hljs-built_in">getScore</span>(nums, l + <span class="hljs-number">1</span>, r), nums[r] - <span class="hljs-built_in">getScore</span>(nums, l, r - <span class="hljs-number">1</span>));<br>        <span class="hljs-comment">//我能获得的分数 - 对手能获得的最大分数</span><br>	&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">PredictTheWinner</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>		m_ = vector&lt;<span class="hljs-keyword">int</span>&gt;(nums.<span class="hljs-built_in">size</span>() * nums.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>);<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">getScore</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &gt;= <span class="hljs-number">0</span>;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>	vector&lt;<span class="hljs-keyword">int</span>&gt; m_;<br>	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getScore</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span>&#123;<br>		<span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span> nums[l];<br>		<span class="hljs-keyword">int</span> k = l * nums.<span class="hljs-built_in">size</span>() + r;<br>		<span class="hljs-keyword">if</span> (m_[k] &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> m_[k];<br>		m_[k] = <span class="hljs-built_in">max</span>(nums[l] - <span class="hljs-built_in">getScore</span>(nums, l + <span class="hljs-number">1</span>, r), nums[r] - <span class="hljs-built_in">getScore</span>(nums, l, r - <span class="hljs-number">1</span>));<br>        <span class="hljs-comment">//我能获得的分数 - 对手能获得的最大分数</span><br>		<span class="hljs-keyword">return</span> m_[k];<br>	&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="450-Delete-Node-in-a-BST-删除二叉搜索树中的节点"><a href="#450-Delete-Node-in-a-BST-删除二叉搜索树中的节点" class="headerlink" title="450. Delete Node in a BST(删除二叉搜索树中的节点)"></a>450. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/delete-node-in-a-bst/">Delete Node in a BST(删除二叉搜索树中的节点)</a></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>		<span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> (TreeNode*)<span class="hljs-literal">nullptr</span>;<br>		<span class="hljs-keyword">if</span> (root-&gt;val == k)&#123;<br>			<span class="hljs-keyword">if</span> (root-&gt;left == <span class="hljs-literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> (TreeNode*)<span class="hljs-literal">nullptr</span>;<br>			<span class="hljs-keyword">if</span> (root-&gt;left == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> root-&gt;right;<br>			<span class="hljs-keyword">if</span> (root-&gt;right == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> root-&gt;left;<br>			TreeNode* temp = root--&gt;right;<br>			<span class="hljs-keyword">while</span> (temp-&gt;left != <span class="hljs-literal">nullptr</span>)&#123;<br>				temp = temp-&gt;left;<br>			&#125;<br>			temp-&gt;left = root-&gt;left;<br>			TreeNode* tmp = root;<br>			root = root-&gt;right;<br>			<span class="hljs-built_in">del</span>(tmp);<br>			<span class="hljs-keyword">return</span> root;<br>		&#125;<br>		<span class="hljs-keyword">if</span> (root-&gt;val &lt; key)<br>			<span class="hljs-keyword">return</span> <span class="hljs-built_in">deleteNode</span>(root-&gt;right, key);<br>		<span class="hljs-keyword">if</span> (root-&gt;val &gt; key)<br>			<span class="hljs-keyword">return</span> <span class="hljs-built_in">deleteNode</span>(root-&gt;left, key);<br>		<span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="普通二叉树的删除方法"><a href="#普通二叉树的删除方法" class="headerlink" title="普通二叉树的删除方法"></a>普通二叉树的删除方法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">if</span> (root-&gt;val == key) &#123;<br>            <span class="hljs-keyword">if</span> (root-&gt;right == <span class="hljs-literal">nullptr</span>) &#123; <span class="hljs-comment">// 这里第二次操作目标值：最终删除的作用</span><br>                <span class="hljs-keyword">return</span> root-&gt;left;<br>            &#125;<br>            TreeNode *cur = root-&gt;right;<br>            <span class="hljs-keyword">while</span> (cur-&gt;left) &#123;<br>                cur = cur-&gt;left;<br>            &#125;<br>            <span class="hljs-built_in">swap</span>(root-&gt;val, cur-&gt;val); <span class="hljs-comment">// 这里第一次操作目标值：交换目标值其右子树最左面节点。</span><br>        &#125;<br>        root-&gt;left = <span class="hljs-built_in">deleteNode</span>(root-&gt;left, key);<br>        root-&gt;right = <span class="hljs-built_in">deleteNode</span>(root-&gt;right, key);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="669-修剪二叉搜索树"><a href="#669-修剪二叉搜索树" class="headerlink" title="669. 修剪二叉搜索树"></a>669. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/">修剪二叉搜索树</a></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">trimBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span> ) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">if</span> (root-&gt;val &lt; low) &#123;<br>            TreeNode* right = <span class="hljs-built_in">trimBST</span>(root-&gt;right, low, high); <span class="hljs-comment">// 寻找符合区间[low, high]的节点</span><br>            <span class="hljs-keyword">return</span> right;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root-&gt;val &gt; high) &#123;<br>            TreeNode* left = <span class="hljs-built_in">trimBST</span>(root-&gt;left, low, high); <span class="hljs-comment">// 寻找符合区间[low, high]的节点</span><br>            <span class="hljs-keyword">return</span> left;<br>        &#125;<br>        root-&gt;left = <span class="hljs-built_in">trimBST</span>(root-&gt;left, low, high); <span class="hljs-comment">// root-&gt;left接入符合条件的左孩子</span><br>        root-&gt;right = <span class="hljs-built_in">trimBST</span>(root-&gt;right, low, high); <span class="hljs-comment">// root-&gt;right接入符合条件的右孩子</span><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701. 二叉搜索树中的插入操作"></a>701. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/">二叉搜索树中的插入操作</a></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">insertIntoBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) &#123;<br>            TreeNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(val);<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root-&gt;val &gt; val) root-&gt;left = <span class="hljs-built_in">insertIntoBST</span>(root-&gt;left, val);<br>        <span class="hljs-keyword">if</span> (root-&gt;val &lt; val) root-&gt;right = <span class="hljs-built_in">insertIntoBST</span>(root-&gt;right, val);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">insertIntoBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) &#123;<br>            TreeNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(val);<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>        TreeNode* cur = root;<br>        TreeNode* parent = root; <span class="hljs-comment">// 这个很重要，需要记录上一个节点，否则无法赋值新节点</span><br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">NULL</span>) &#123;<br>            parent = cur;<br>            <span class="hljs-keyword">if</span> (cur-&gt;val &gt; val) cur = cur-&gt;left;<br>            <span class="hljs-keyword">else</span> cur = cur-&gt;right;<br>        &#125;<br>        TreeNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(val);<br>        <span class="hljs-keyword">if</span> (val &lt; parent-&gt;val) parent-&gt;left = node;<span class="hljs-comment">// 此时是用parent节点的进行赋值</span><br>        <span class="hljs-keyword">else</span> parent-&gt;right = node;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="315-Count-of-Smaller-Numbers-After-Self-计算右侧小于当前元素的个数"><a href="#315-Count-of-Smaller-Numbers-After-Self-计算右侧小于当前元素的个数" class="headerlink" title="315. Count of Smaller Numbers After Self(计算右侧小于当前元素的个数)"></a>315. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problemset/all/?search=315">Count of Smaller Numbers After Self(计算右侧小于当前元素的个数)</a></h2><h3 id="方法一：Brute-Force-3"><a href="#方法一：Brute-Force-3" class="headerlink" title="方法一：Brute Force"></a>方法一：Brute Force</h3><p>check every pair of numbers</p>
<h3 id="方法一：Fenwick-Tree-Binary-Indexed-Tree"><a href="#方法一：Fenwick-Tree-Binary-Indexed-Tree" class="headerlink" title="方法一：Fenwick Tree/ Binary Indexed Tree"></a>方法一：Fenwick Tree/ Binary Indexed Tree</h3><p>for each number we would like to konw how many numbers are smaller than it if we view the input array in reversed order<br>[5, 2, 6, 1] -&gt; [1, 6, 2, 5]<br>1 -&gt; [], 6 -&gt; [1], 2 -&gt; [1], 5 -&gt; [1,2]<br>将问题转换成求频率和<br>convert the number to its rank as in sorted array</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FenwickTree</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">FenwickTree</span>(<span class="hljs-keyword">int</span> n) : <span class="hljs-built_in">sums_</span>(n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)&#123;&#125;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> delta)</span></span>&#123;<br>		<span class="hljs-keyword">while</span> (i &lt; sums_.<span class="hljs-built_in">size</span>())&#123;<br>			sums_[i] = sums_[i] + delta;<br>			i = i + <span class="hljs-built_in">lowbit</span>(i);<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;<br>		<span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">0</span>)&#123;<br>			sum = sum + sums_[i];<br>			i = i - <span class="hljs-built_in">lowbit</span>(i);<br>		&#125;<br>		<span class="hljs-keyword">return</span> sum;<br>	&#125;<br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>		<span class="hljs-keyword">return</span> x &amp; (-x);<br>	&#125;<br>	vector&lt;<span class="hljs-keyword">int</span>&gt; sums_;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">countSmaller</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>		<span class="hljs-function">set&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sorted</span><span class="hljs-params">(nums.begin(), nums.end())</span></span>;<br>		unordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; ranks;<br>        <span class="hljs-keyword">int</span> rank = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> num : sorted)<br>            ranks[num] = ++rank;<br>		vector&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>		<span class="hljs-function">FenwickTree <span class="hljs-title">tree</span><span class="hljs-params">(ranks.size())</span></span>;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>			ans.<span class="hljs-built_in">push_back</span>(tree.<span class="hljs-built_in">query</span>(ranks[nums[i]] - <span class="hljs-number">1</span>));<br>			tree.<span class="hljs-built_in">update</span>(ranks[nums[i]], <span class="hljs-number">1</span>);<br>		&#125;<br>		<span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>());<br>		<span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="方法三：Binary-Indexed-Tree"><a href="#方法三：Binary-Indexed-Tree" class="headerlink" title="方法三：Binary Indexed Tree"></a>方法三：Binary Indexed Tree</h3><p>track the number of elements smaller than the current node<br>count the total number of elements smaller than val during inserting val into the tree<br>each node: val, count, left_count</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BSTNode</span> &#123;</span><br>    <span class="hljs-keyword">int</span> val;<br>    <span class="hljs-keyword">int</span> count;<br>    <span class="hljs-keyword">int</span> left_count;<br>    BSTNode* left;<br>    BSTNode* right;    <br>    <span class="hljs-built_in">BSTNode</span>(<span class="hljs-keyword">int</span> val): <span class="hljs-built_in">val</span>(val), <span class="hljs-built_in">count</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">left_count</span>(<span class="hljs-number">0</span>), left&#123;<span class="hljs-literal">nullptr</span>&#125;, right&#123;<span class="hljs-literal">nullptr</span>&#125; &#123;&#125;<br>    ~<span class="hljs-built_in">BSTNode</span>() &#123; <span class="hljs-keyword">delete</span> left; <span class="hljs-keyword">delete</span> right; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">less_or_equal</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> count + left_count; &#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">countSmaller</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> &#123;&#125;;<br>        std::<span class="hljs-built_in">reverse</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-function">std::unique_ptr&lt;BSTNode&gt; <span class="hljs-title">root</span><span class="hljs-params">(<span class="hljs-keyword">new</span> BSTNode(nums[<span class="hljs-number">0</span>]))</span></span>;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; ans&#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)<br>            ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">insert</span>(root.<span class="hljs-built_in">get</span>(), nums[i]));<br>        std::<span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// Returns the number of elements smaller than val under root.</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(BSTNode* root, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root-&gt;val == val) &#123;<br>            ++root-&gt;count;<br>            <span class="hljs-keyword">return</span> root-&gt;left_count;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val &lt; root-&gt;val) &#123;<br>            ++root-&gt;left_count;<br>            <span class="hljs-keyword">if</span> (root-&gt;left == <span class="hljs-literal">nullptr</span>) &#123;<br>                root-&gt;left = <span class="hljs-keyword">new</span> <span class="hljs-built_in">BSTNode</span>(val);            <br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125; <br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">insert</span>(root-&gt;left, val);<br>        &#125; <span class="hljs-keyword">else</span>  &#123;<br>            <span class="hljs-keyword">if</span> (root-&gt;right == <span class="hljs-literal">nullptr</span>) &#123;<br>                root-&gt;right = <span class="hljs-keyword">new</span> <span class="hljs-built_in">BSTNode</span>(val);<br>                <span class="hljs-keyword">return</span> root-&gt;<span class="hljs-built_in">less_or_equal</span>();<br>            &#125;<br>            <span class="hljs-keyword">return</span> root-&gt;<span class="hljs-built_in">less_or_equal</span>() + <span class="hljs-built_in">insert</span>(root-&gt;right, val);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="297-Serialize-and-Deserialize-Binary-Tree-二叉树的序列化与反序列化"><a href="#297-Serialize-and-Deserialize-Binary-Tree-二叉树的序列化与反序列化" class="headerlink" title="297. Serialize and Deserialize Binary Tree(二叉树的序列化与反序列化)"></a>297. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/">Serialize and Deserialize Binary Tree(二叉树的序列化与反序列化)</a></h2><h3 id="方法一：Recursion-string"><a href="#方法一：Recursion-string" class="headerlink" title="方法一：Recursion + string"></a>方法一：Recursion + string</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Codec</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-comment">// Encodes a tree to a single string.</span><br>    <span class="hljs-function">string <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        ostringstream out;<br>		<span class="hljs-built_in">serialize</span>(root, out);<br>		<span class="hljs-keyword">return</span> out.<span class="hljs-built_in">str</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// Decodes your encoded data to tree.</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deserialize</span><span class="hljs-params">(string data)</span> </span>&#123;<br>        <span class="hljs-function">istringstream <span class="hljs-title">in</span><span class="hljs-params">(data)</span></span>;<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">deserialize</span>(in);<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode* root, ostringstream&amp; out)</span></span>&#123;<br>		<span class="hljs-keyword">if</span>(!root)&#123;<br>			out &lt;&lt; <span class="hljs-string">&quot;# &quot;</span>;<br>			<span class="hljs-keyword">return</span>;<br>		&#125;<br>		out &lt;&lt; root-&gt;val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>		<span class="hljs-built_in">serialize</span>(root-&gt;left, out);<br>		<span class="hljs-built_in">serialize</span>(root-&gt;right, out);<br>	&#125;<br>	<br>	<span class="hljs-function">TreeNode* <span class="hljs-title">deserialize</span><span class="hljs-params">(istringstream&amp; in)</span> </span>&#123;<br>        string val;<br>        in &gt;&gt; val;<br>        <span class="hljs-keyword">if</span> (val == <span class="hljs-string">&quot;#&quot;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;        <br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-built_in">stoi</span>(val));        <br>        root-&gt;left = <span class="hljs-built_in">deserialize</span>(in);<br>        root-&gt;right = <span class="hljs-built_in">deserialize</span>(in);        <br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// Your Codec object will be instantiated and called as such:</span><br><span class="hljs-comment">// Codec ser, deser;</span><br><span class="hljs-comment">// TreeNode* ans = deser.deserialize(ser.serialize(root));</span><br></code></pre></td></tr></table></figure>

<h3 id="方法二：Recursion-Binary"><a href="#方法二：Recursion-Binary" class="headerlink" title="方法二：Recursion + Binary"></a>方法二：Recursion + Binary</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Codec</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-comment">// Encodes a tree to a single string.</span><br>    <span class="hljs-function">string <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        ostringstream out;<br>		<span class="hljs-built_in">serialize</span>(root, out);<br>		<span class="hljs-keyword">return</span> out.<span class="hljs-built_in">str</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// Decodes your encoded data to tree.</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deserialize</span><span class="hljs-params">(string data)</span> </span>&#123;<br>        <span class="hljs-function">istringstream <span class="hljs-title">in</span><span class="hljs-params">(data)</span></span>;<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">deserialize</span>(in);<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">STATUS</span> &#123;</span><br>        ROOT_NULL = <span class="hljs-number">0x0</span>,<br>        ROOT = <span class="hljs-number">0x1</span>,<br>        LEFT = <span class="hljs-number">0x2</span>,<br>        RIGHT = <span class="hljs-number">0x4</span><br>    &#125;;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode* root, ostringstream&amp; out)</span></span>&#123;<br>		<span class="hljs-keyword">char</span> status = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (root) status |= ROOT;<br>        <span class="hljs-keyword">if</span> (root &amp;&amp; root-&gt;left) status |= LEFT;<br>        <span class="hljs-keyword">if</span> (root &amp;&amp; root-&gt;right) status |= RIGHT;<br>        out.<span class="hljs-built_in">write</span>(&amp;status, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">char</span>));        <br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;<br>        out.<span class="hljs-built_in">write</span>(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">char</span>*&gt;(&amp;(root-&gt;val)), <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(root-&gt;val));<br>        <span class="hljs-keyword">if</span> (root-&gt;left) <span class="hljs-built_in">serialize</span>(root-&gt;left, out);<br>        <span class="hljs-keyword">if</span> (root-&gt;right) <span class="hljs-built_in">serialize</span>(root-&gt;right, out);<br>	&#125;<br>	<br>	<span class="hljs-function">TreeNode* <span class="hljs-title">deserialize</span><span class="hljs-params">(istringstream&amp; in)</span> </span>&#123;<br>        <span class="hljs-keyword">char</span> status;<br>        in.<span class="hljs-built_in">read</span>(&amp;status, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">char</span>));<br>        <span class="hljs-keyword">if</span> (!status &amp; ROOT) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">auto</span> root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">0</span>);<br>        in.<span class="hljs-built_in">read</span>(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">char</span>*&gt;(&amp;root-&gt;val), <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(root-&gt;val));        <br>        root-&gt;left = (status &amp; LEFT) ? <span class="hljs-built_in">deserialize</span>(in) : <span class="hljs-literal">nullptr</span>;<br>        root-&gt;right = (status &amp; RIGHT) ? <span class="hljs-built_in">deserialize</span>(in) : <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="449-Serialize-and-Deserialize-BST-序列化和反序列化二叉搜索树"><a href="#449-Serialize-and-Deserialize-BST-序列化和反序列化二叉搜索树" class="headerlink" title="449. Serialize and Deserialize BST(序列化和反序列化二叉搜索树)"></a>449. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/serialize-and-deserialize-bst/">Serialize and Deserialize BST(序列化和反序列化二叉搜索树)</a></h2><h3 id="方法一：Recursion-7"><a href="#方法一：Recursion-7" class="headerlink" title="方法一：Recursion"></a>方法一：Recursion</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Codec</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-comment">// Encodes a tree to a single string.</span><br>    <span class="hljs-function">string <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        string s;<br>        <span class="hljs-built_in">serialize</span>(root, s);<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br><br>    <span class="hljs-comment">// Decodes your encoded data to tree.</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deserialize</span><span class="hljs-params">(string data)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> pos = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">deserialize</span>(data, pos, INT_MIN, INT_MAX);<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode* root, string&amp; s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;    <br>        s.<span class="hljs-built_in">append</span>(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*&gt;(&amp;root-&gt;val), <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(root-&gt;val));<br>        <span class="hljs-built_in">serialize</span>(root-&gt;left, s);<br>        <span class="hljs-built_in">serialize</span>(root-&gt;right, s);<br>    &#125;<br>    <br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deserialize</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string&amp; s, <span class="hljs-keyword">int</span>&amp; pos, <span class="hljs-keyword">int</span> curMin, <span class="hljs-keyword">int</span> curMax)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (pos &gt;= s.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">int</span> val = *<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>*&gt;(s.<span class="hljs-built_in">data</span>() + pos);<br>        <span class="hljs-keyword">if</span> (val &lt; curMin || val &gt; curMax) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        pos += <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(val);<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(val);<br>        root-&gt;left = <span class="hljs-built_in">deserialize</span>(s, pos, curMin, val);<br>        root-&gt;right = <span class="hljs-built_in">deserialize</span>(s, pos, val, curMax);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// Your Codec object will be instantiated and called as such:</span><br><span class="hljs-comment">// Codec* ser = new Codec();</span><br><span class="hljs-comment">// Codec* deser = new Codec();</span><br><span class="hljs-comment">// string tree = ser-&gt;serialize(root);</span><br><span class="hljs-comment">// TreeNode* ans = deser-&gt;deserialize(tree);</span><br><span class="hljs-comment">// return ans;</span><br></code></pre></td></tr></table></figure>

<h2 id="652-Find-Duplicate-Subtrees-寻找重复的子树"><a href="#652-Find-Duplicate-Subtrees-寻找重复的子树" class="headerlink" title="652. Find Duplicate Subtrees(寻找重复的子树)"></a>652. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-duplicate-subtrees/">Find Duplicate Subtrees(寻找重复的子树)</a></h2><h3 id="方法一：-1"><a href="#方法一：-1" class="headerlink" title="方法一："></a>方法一：</h3><p>use hashtable to record times a serialized subtree occured</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;TreeNode*&gt; <span class="hljs-title">findDuplicateSubtrees</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>		unordered_map&lt;string, <span class="hljs-keyword">int</span>&gt; counts;<br>        vector&lt;TreeNode*&gt; ans;<br>        <span class="hljs-built_in">serialize</span>(root, counts, ans);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function">string <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode* root, unordered_map&lt;string, <span class="hljs-keyword">int</span>&gt;&amp; counts, vector&lt;TreeNode*&gt;&amp; ans)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;#&quot;</span>;<br>        string key = <span class="hljs-built_in">to_string</span>(root-&gt;val) + <span class="hljs-string">&quot;,&quot;</span> <br>                     + <span class="hljs-built_in">serialize</span>(root-&gt;left, counts, ans) + <span class="hljs-string">&quot;,&quot;</span> <br>                     + <span class="hljs-built_in">serialize</span>(root-&gt;right, counts, ans);<br>        <span class="hljs-keyword">if</span> (++counts[key] == <span class="hljs-number">2</span>)<br>            ans.<span class="hljs-built_in">push_back</span>(root);<br>        <span class="hljs-keyword">return</span> key;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><p>assign each unique subtree a unique id<br>key: (root.val, id(root.left), id(root.right))</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;TreeNode*&gt; <span class="hljs-title">findDuplicateSubtrees</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>		unordered_map&lt;<span class="hljs-keyword">long</span>, pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt; counts;    <br>		vector&lt;TreeNode*&gt; ans;<br>		<span class="hljs-built_in">getId</span>(root, counts, ans);<br>		<span class="hljs-keyword">return</span> ans;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">(TreeNode* root, </span></span><br><span class="hljs-params"><span class="hljs-function">            unordered_map&lt;<span class="hljs-keyword">long</span>, pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt;&amp; counts,</span></span><br><span class="hljs-params"><span class="hljs-function">            vector&lt;TreeNode*&gt;&amp; ans)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">long</span> key = (<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">long</span>&gt;(<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">unsigned</span>&gt;(root-&gt;val)) &lt;&lt; <span class="hljs-number">32</span>) +<br>               (<span class="hljs-built_in">getId</span>(root-&gt;left, counts, ans) &lt;&lt; <span class="hljs-number">16</span>) +<br>                <span class="hljs-built_in">getId</span>(root-&gt;right, counts, ans);    <br>    <span class="hljs-keyword">auto</span>&amp; p = counts[key];<br>    <span class="hljs-keyword">if</span> (p.second++ == <span class="hljs-number">0</span>)<br>      p.first = counts.<span class="hljs-built_in">size</span>();    <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p.second == <span class="hljs-number">2</span>)<br>      ans.<span class="hljs-built_in">push_back</span>(root);<br>    <span class="hljs-keyword">return</span> p.first;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="742-Closest-Leaf-in-a-Binary-Tree-二叉树最近的叶节点"><a href="#742-Closest-Leaf-in-a-Binary-Tree-二叉树最近的叶节点" class="headerlink" title="742. Closest Leaf in a Binary Tree(二叉树最近的叶节点)"></a>742. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/closest-leaf-in-a-binary-tree/">Closest Leaf in a Binary Tree(二叉树最近的叶节点)</a></h2><p>给你一棵树，每个节点的值都不相同。<br>给定一个节点值，让你找到离这个节点距离最近的叶子节点的值。</p>
<h3 id="方法一：BFS"><a href="#方法一：BFS" class="headerlink" title="方法一：BFS"></a>方法一：BFS</h3><p>问题转换为在无向/等权重的图中找一条从起始节点到任意叶子节点最短路径。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findClosestLeaf</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        graph_.<span class="hljs-built_in">clear</span>();<br>        start_ = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-built_in">buildGraph</span>(root, <span class="hljs-literal">nullptr</span>, k);<br>        queue&lt;TreeNode*&gt; q;<br>        q.<span class="hljs-built_in">push</span>(start_);<br>        unordered_set&lt;TreeNode*&gt; seen;<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">int</span> size = q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">while</span> (size--&gt;<span class="hljs-number">0</span>) &#123;<br>                TreeNode* curr = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();                <br>                seen.<span class="hljs-built_in">insert</span>(curr);                <br>                <span class="hljs-keyword">if</span> (!curr-&gt;left &amp;&amp; !curr-&gt;right) <span class="hljs-keyword">return</span> curr-&gt;val;<br>                <span class="hljs-keyword">for</span> (TreeNode* node : graph_[curr])<br>                    <span class="hljs-keyword">if</span> (!seen.<span class="hljs-built_in">count</span>(node)) q.<span class="hljs-built_in">push</span>(node);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildGraph</span><span class="hljs-params">(TreeNode* node, TreeNode* parent, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (node-&gt;val == k) start_ = node;<br>        <span class="hljs-keyword">if</span> (parent) &#123;<br>            graph_[node].<span class="hljs-built_in">push_back</span>(parent);<br>            graph_[parent].<span class="hljs-built_in">push_back</span>(node);<br>        &#125;<br>        <span class="hljs-built_in">buildGraph</span>(node-&gt;left, node, k);<br>        <span class="hljs-built_in">buildGraph</span>(node-&gt;right, node, k);<br>    &#125;<br>    <br>    unordered_map&lt;TreeNode*, vector&lt;TreeNode*&gt;&gt; graph_;<br>    TreeNode* start_;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="745-Prefix-and-Suffix-Search-前缀和后缀搜索"><a href="#745-Prefix-and-Suffix-Search-前缀和后缀搜索" class="headerlink" title="745. Prefix and Suffix Search(前缀和后缀搜索)"></a>745. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/prefix-and-suffix-search/">Prefix and Suffix Search(前缀和后缀搜索)</a></h2><h3 id="方法一：hashtable"><a href="#方法一：hashtable" class="headerlink" title="方法一：hashtable"></a>方法一：hashtable</h3><p>Construct all possible filters<br>key = {prefix}_{suffix}<br>apple: [<em>, a_e, ap_le, appl_ple</em>,……,apple_apple]<br>a world of length L has L^2 possible keys<br>hashtable: key -&gt; word_index<br>Time complexity: O(NL^3 + QL)  where N is the number of words, L is the max length of the word, Q is the number of queries.<br>Space complexity: O(NL^3)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WordFilter</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">WordFilter</span>(vector&lt;string&gt;&amp; words) &#123;<br>		<span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> string&amp; word : words) &#123;<br>            <span class="hljs-keyword">int</span> n = word.<span class="hljs-built_in">length</span>();<br>            <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">prefixes</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-string">&quot;&quot;</span>)</span></span>;<br>            <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">suffixes</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-string">&quot;&quot;</span>)</span></span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>                prefixes[i + <span class="hljs-number">1</span>] = prefixes[i] + word[i];<br>                suffixes[i + <span class="hljs-number">1</span>] = word[n - i - <span class="hljs-number">1</span>] + suffixes[i];<br>            &#125;<br>            <br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> string&amp; prefix : prefixes)&#123;          <br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> string&amp; suffix : suffixes)                              <br>                    filters_[prefix + <span class="hljs-string">&quot;_&quot;</span> + suffix] = index; <br>			&#125;					<br>            ++index;<br>        &#125;     <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(string prefix, string suffix)</span> </span>&#123;<br>		<span class="hljs-keyword">const</span> string key = prefix + <span class="hljs-string">&quot;_&quot;</span> + suffix;<br>        <span class="hljs-keyword">auto</span> it = filters_.<span class="hljs-built_in">find</span>(key);<br>        <span class="hljs-keyword">if</span> (it != filters_.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">return</span> it-&gt;second;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    unordered_map&lt;string, <span class="hljs-keyword">int</span>&gt; filters_;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your WordFilter object will be instantiated and called as such:</span><br><span class="hljs-comment"> * WordFilter* obj = new WordFilter(words);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;f(prefix,suffix);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>

<h3 id="方法二：Trie"><a href="#方法二：Trie" class="headerlink" title="方法二：Trie"></a>方法二：Trie</h3><p>Query {suffix}_{prefix}, e.g. {le_ap}<br>for every world, we insert {suffixes}_word into trie<br>Time complexity: O(NL^2 + QL)  where N is the number of words, L is the max length of the word, Q is the number of queries.<br>Space complexity: O(NL^2)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-built_in">Trie</span>(): <span class="hljs-built_in">root_</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">TrieNode</span>()) &#123;&#125;<br>    <br>    <span class="hljs-comment">/** Inserts a word into the trie. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string&amp; word, <span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        TrieNode* p = root_.<span class="hljs-built_in">get</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> c : word) &#123;            <br>            <span class="hljs-keyword">if</span> (!p-&gt;children[c - <span class="hljs-string">&#x27;a&#x27;</span>])<br>                p-&gt;children[c - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TrieNode</span>();<br>            p = p-&gt;children[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>            <span class="hljs-comment">// Update index</span><br>            p-&gt;index = index;<br>        &#125;<br>        p-&gt;is_word = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <br>    <span class="hljs-comment">/** Returns the index of word that has the prefix. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string&amp; prefix)</span> <span class="hljs-keyword">const</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> node = <span class="hljs-built_in">find</span>(prefix);<br>        <span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> node-&gt;index;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TrieNode</span> &#123;</span><br>        <span class="hljs-built_in">TrieNode</span>():<span class="hljs-built_in">index</span>(<span class="hljs-number">-1</span>), <span class="hljs-built_in">is_word</span>(<span class="hljs-literal">false</span>), <span class="hljs-built_in">children</span>(<span class="hljs-number">27</span>, <span class="hljs-literal">nullptr</span>)&#123;&#125;<br>        <br>        ~<span class="hljs-built_in">TrieNode</span>() &#123;<br>            <span class="hljs-keyword">for</span> (TrieNode* child : children)<br>                <span class="hljs-keyword">if</span> (child) <span class="hljs-keyword">delete</span> child;<br>        &#125;<br>        <br>        <span class="hljs-keyword">int</span> index;<br>        <span class="hljs-keyword">int</span> is_word;<br>        vector&lt;TrieNode*&gt; children;<br>    &#125;;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">const</span> TrieNode* <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string&amp; prefix)</span> <span class="hljs-keyword">const</span> </span>&#123;<br>        <span class="hljs-keyword">const</span> TrieNode* p = root_.<span class="hljs-built_in">get</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> c : prefix) &#123;<br>            p = p-&gt;children[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>            <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>    <br>    std::unique_ptr&lt;TrieNode&gt; root_;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WordFilter</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">WordFilter</span>(vector&lt;string&gt; words) &#123;        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; words.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">const</span> string&amp; w = words[i];            <br>            string key = <span class="hljs-string">&quot;&#123;&quot;</span> + w;<br>            trie_.<span class="hljs-built_in">insert</span>(key, i);            <br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; w.<span class="hljs-built_in">size</span>(); ++j) &#123;<br>                key = w[w.<span class="hljs-built_in">size</span>() - j - <span class="hljs-number">1</span>] + key;                <br>                trie_.<span class="hljs-built_in">insert</span>(key, i);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(string prefix, string suffix)</span> </span>&#123;        <br>        <span class="hljs-keyword">return</span> trie_.<span class="hljs-built_in">startsWith</span>(suffix + <span class="hljs-string">&quot;&#123;&quot;</span> + prefix);<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    Trie trie_;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="530-Minimum-Absolute-Difference-in-BST-二叉搜索树的最小绝对差"><a href="#530-Minimum-Absolute-Difference-in-BST-二叉搜索树的最小绝对差" class="headerlink" title="530. Minimum Absolute Difference in BST(二叉搜索树的最小绝对差)"></a>530. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/">Minimum Absolute Difference in BST(二叉搜索树的最小绝对差)</a></h2><h3 id="方法一：Inorder"><a href="#方法一：Inorder" class="headerlink" title="方法一：Inorder"></a>方法一：Inorder</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getMinimumDifference</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>		vector&lt;<span class="hljs-keyword">int</span>&gt; num;<br>		<span class="hljs-built_in">Inorder</span>(root, num);<br>		<span class="hljs-keyword">int</span> result = INT_MAX;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++)&#123;<br>			result = <span class="hljs-built_in">min</span>(result, num[i + <span class="hljs-number">1</span>] - num[i]);<br>		&#125;<br>		<span class="hljs-keyword">return</span> result;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Inorder</span><span class="hljs-params">(TreeNode* root, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; num)</span></span>&#123;<br>		<span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;<br>		<span class="hljs-built_in">Inorder</span>(root-&gt;left, num);<br>		num.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>		<span class="hljs-built_in">Inorder</span>(root-&gt;right, num);<br>	&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="98-Validate-Binary-Search-Tree"><a href="#98-Validate-Binary-Search-Tree" class="headerlink" title="98. Validate Binary Search Tree"></a>98. <a href="">Validate Binary Search Tree</a></h2><h3 id="方法一：Inorder-1"><a href="#方法一：Inorder-1" class="headerlink" title="方法一：Inorder"></a>方法一：Inorder</h3><p>Values should be sorted, check current value </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>	TreeNode* pre = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//用来记录前一个节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>		<span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">bool</span> left = <span class="hljs-built_in">isValidBST</span>(root-&gt;left);<br>		<br>        <span class="hljs-keyword">if</span>(pre != <span class="hljs-literal">NULL</span> &amp;&amp; pre-&gt;val &gt;= root-&gt;val)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        pre = root;<br><br>        <span class="hljs-keyword">bool</span> right = <span class="hljs-built_in">isValidBST</span>(root-&gt;right);<br><br>        <span class="hljs-keyword">return</span> left &amp;&amp; right;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="方法二：贪心算法"><a href="#方法二：贪心算法" class="headerlink" title="方法二：贪心算法"></a>方法二：贪心算法</h3><p>limit the value range for the sub-trees<br>每个结点值的可能的最大范围</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>	TreeNode* pre = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">isValidBST</span>(root, LLONG_MIN, LLONG_MAX);<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">long</span> min_val, <span class="hljs-keyword">long</span> max_val)</span></span>&#123;<br>		<span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>		<span class="hljs-keyword">if</span> (root-&gt;val &lt;= min_val || root-&gt;val &gt;= max_val)<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>		<span class="hljs-keyword">bool</span> left = <span class="hljs-built_in">isValidBST</span>(root-&gt;left, min_val, root-&gt;val);<br>		<span class="hljs-keyword">bool</span> right = <span class="hljs-built_in">isValidBST</span>(root-&gt;right, root-&gt;val, max_val);<br>		<span class="hljs-keyword">return</span> left &amp;&amp; right;<br>	&#125;	<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257. 二叉树的所有路径"></a>257. 二叉树的所有路径</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; path, vector&lt;string&gt;&amp; result)</span> </span>&#123;<br>        path.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>        <span class="hljs-comment">// 这才到了叶子节点</span><br>        <span class="hljs-keyword">if</span> (cur-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; cur-&gt;right == <span class="hljs-literal">NULL</span>) &#123;<br>            string sPath;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; path.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++) &#123;<br>                sPath += <span class="hljs-built_in">to_string</span>(path[i]);<br>                sPath += <span class="hljs-string">&quot;-&gt;&quot;</span>;<br>            &#125;<br>            sPath += <span class="hljs-built_in">to_string</span>(path[path.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>]);<br>            result.<span class="hljs-built_in">push_back</span>(sPath);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (cur-&gt;left) &#123;<br>            <span class="hljs-built_in">traversal</span>(cur-&gt;left, path, result);<br>            path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (cur-&gt;right) &#123;<br>            <span class="hljs-built_in">traversal</span>(cur-&gt;right, path, result);<br>            path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯</span><br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">binaryTreePaths</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;string&gt; result;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; path;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> result;<br>        <span class="hljs-built_in">traversal</span>(root, path, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<h2 id="递归函数是否需要有返回值？"><a href="#递归函数是否需要有返回值？" class="headerlink" title="递归函数是否需要有返回值？"></a>递归函数是否需要有返回值？</h2><p>没有返回值，搜素整棵树；有返回值，搜索到一个满足条件的即可返回</p>
<p>如果递归函数有返回值，如何区分要搜索一条边，还是搜索整个树。</p>
<p>搜索一条边的写法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (递归函数(root-&gt;left)) <span class="hljs-keyword">return</span> ;<br><br><span class="hljs-keyword">if</span> (递归函数(root-&gt;right)) <span class="hljs-keyword">return</span> ;<br></code></pre></td></tr></table></figure>

<p>搜索整个树的写法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">left = 递归函数(root-&gt;left);<br>right = 递归函数(root-&gt;right);<br>left与right的逻辑处理;<br></code></pre></td></tr></table></figure>



<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><h3 id="二叉树的前序、后序、中序遍历"><a href="#二叉树的前序、后序、中序遍历" class="headerlink" title="二叉树的前序、后序、中序遍历"></a>二叉树的前序、后序、中序遍历</h3><h4 id="递归实现-以中序为例"><a href="#递归实现-以中序为例" class="headerlink" title="递归实现(以中序为例)"></a>递归实现(以中序为例)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; vec)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">traversal</span>(cur-&gt;left, vec);  <span class="hljs-comment">// 左</span><br>    vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);    <span class="hljs-comment">// 中</span><br>    <span class="hljs-built_in">traversal</span>(cur-&gt;right, vec); <span class="hljs-comment">// 右</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="迭代实现-非统一的"><a href="#迭代实现-非统一的" class="headerlink" title="迭代实现(非统一的)"></a>迭代实现(非统一的)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//前序</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        stack&lt;TreeNode*&gt; st;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; result;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> result;<br>        st.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>            TreeNode* node = st.<span class="hljs-built_in">top</span>();                       <span class="hljs-comment">// 中</span><br>            st.<span class="hljs-built_in">pop</span>();<br>            result.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>            <span class="hljs-keyword">if</span> (node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);           <span class="hljs-comment">// 右（空节点不入栈）</span><br>            <span class="hljs-keyword">if</span> (node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);             <span class="hljs-comment">// 左（空节点不入栈）</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//中序</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; result;<br>        stack&lt;TreeNode*&gt; st;<br>        TreeNode* cur = root;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">NULL</span> || !st.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">if</span> (cur != <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">// 指针来访问节点，访问到最底层</span><br>                st.<span class="hljs-built_in">push</span>(cur); <span class="hljs-comment">// 将访问的节点放进栈</span><br>                cur = cur-&gt;left;                <span class="hljs-comment">// 左</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur = st.<span class="hljs-built_in">top</span>(); <span class="hljs-comment">// 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）</span><br>                st.<span class="hljs-built_in">pop</span>();<br>                result.<span class="hljs-built_in">push_back</span>(cur-&gt;val);     <span class="hljs-comment">// 中</span><br>                cur = cur-&gt;right;               <span class="hljs-comment">// 右</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="迭代实现-统一的"><a href="#迭代实现-统一的" class="headerlink" title="迭代实现(统一的)"></a>迭代实现(统一的)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; result;<br>        stack&lt;TreeNode*&gt; st;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) st.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>            TreeNode* node = st.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">NULL</span>) &#123;<br>                st.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span><br>                <span class="hljs-keyword">if</span> (node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);  <span class="hljs-comment">// 添加右节点（空节点不入栈）</span><br><br>                st.<span class="hljs-built_in">push</span>(node);                          <span class="hljs-comment">// 添加中节点</span><br>                st.<span class="hljs-built_in">push</span>(<span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 中节点访问过，但是还没有处理，加入空节点做为标记。</span><br><br>                <span class="hljs-keyword">if</span> (node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);    <span class="hljs-comment">// 添加左节点（空节点不入栈）</span><br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 只有遇到空节点的时候，才将下一个节点放进结果集</span><br>                st.<span class="hljs-built_in">pop</span>();           <span class="hljs-comment">// 将空节点弹出</span><br>                node = st.<span class="hljs-built_in">top</span>();    <span class="hljs-comment">// 重新取出栈中元素</span><br>                st.<span class="hljs-built_in">pop</span>();<br>                result.<span class="hljs-built_in">push_back</span>(node-&gt;val); <span class="hljs-comment">// 加入到结果集</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>        queue&lt;TreeNode*&gt; que;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; result;<br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            vector&lt;<span class="hljs-keyword">int</span>&gt; vec;<br>            <span class="hljs-comment">// 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                vec.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>                <span class="hljs-keyword">if</span> (node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span> (node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>            result.<span class="hljs-built_in">push_back</span>(vec);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


      </section>
      <section class="extra">
        
          <ul class="copyright">
  
    <li><strong>本文作者：</strong>Mengyuan Chen</li>
    <li><strong>本文链接：</strong><a href="http://example.com/2021/07/28/LeetCode/Tree%E6%A0%91/index.html" title="http:&#x2F;&#x2F;example.com&#x2F;2021&#x2F;07&#x2F;28&#x2F;LeetCode&#x2F;Tree%E6%A0%91&#x2F;index.html">http:&#x2F;&#x2F;example.com&#x2F;2021&#x2F;07&#x2F;28&#x2F;LeetCode&#x2F;Tree%E6%A0%91&#x2F;index.html</a></li>
    <li><strong>版权声明：</strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" title="BY-NC-SA" target="_blank" rel="noopener">BY-NC-SA</a> 许可协议，转载请注明出处！</li>
  
</ul>
        
        
          <section class="donate">
  <div id="qrcode-donate">
    <img   class="lazyload" data-original="https://sm.ms/image/Y6TiL7UgNHm2RSl" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" >
  </div>
  <div class="icon">
    <a href="javascript:;" id="alipay"><i class="iconfont iconalipay"></i></a>
    <a href="javascript:;" id="wechat"><i class="iconfont iconwechat-fill"></i></a>
  </div>
</section>
        
        
  <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/TopologicalSort/" rel="tag">TopologicalSort</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/" rel="tag">拓扑排序</a></li></ul> 

        
  <nav class="nav">
    <a href="/2021/08/11/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"><i class="iconfont iconleft"></i>深度学习推荐系统</a>
    <a href="/2021/07/21/LeetCode/Math%E6%95%B0%E5%AD%A6/">Math数学<i class="iconfont iconright"></i></a>
  </nav>

      </section>
      
    </section>
  </div>
</article></div>
      <div class="col-xl-3">
        
          
  <aside class="toc-wrap">
    <h3 class="toc-title">文章目录：</h3>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91-Tree"><span class="toc-text">树(Tree)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91segment-tree"><span class="toc-text">线段树segment tree</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-text">最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9APrim%E7%AE%97%E6%B3%95"><span class="toc-text">方法一：Prim算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9AKruskal%E2%80%99s-Algorithm"><span class="toc-text">方法二：Kruskal’s Algorithm</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#208-Implement-Trie-Prefix-Tree-%E5%AE%9E%E7%8E%B0Trie-%E5%89%8D%E7%BC%80%E6%A0%91"><span class="toc-text">208. Implement Trie (Prefix Tree)(实现Trie(前缀树))</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#421-Maximum-XOR-of-Two-Numbers-in-an-Array-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-text">421. Maximum XOR of Two Numbers in an Array(数组中的两个数的最大值)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A"><span class="toc-text">方法一：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1707-Maximum-XOR-With-an-Element-From-Array-%E4%B8%8E%E6%95%B0%E7%BB%84%E4%B8%AD%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%80%BC"><span class="toc-text">1707. Maximum XOR With an Element From Array(与数组中元素的最大异或值)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E5%89%8D%E7%BC%80%E6%A0%91"><span class="toc-text">方法一：前缀树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#235-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-text">235. 二叉搜索树的最近公共祖先</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-text">236. 二叉树的最近公共祖先</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#506-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0"><span class="toc-text">506. 二叉搜索树中的众数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E4%B8%8D%E6%98%AF%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">如果不是二叉搜索树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1617-Count-Subtrees-With-Max-Distance-Between-Cities-%E7%BB%9F%E8%AE%A1%E5%AD%90%E6%A0%91%E4%B8%AD%E5%9F%8E%E5%B8%82%E4%B9%8B%E9%97%B4%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%9D%E7%A6%BB"><span class="toc-text">1617. Count Subtrees With Max Distance Between Cities(统计子树中城市之间的最大距离)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9ABrute-Force"><span class="toc-text">方法一：Brute Force</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9ADP-on-Trees"><span class="toc-text">方法二：DP on Trees</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1530-Number-of-Good-Leaf-Nodes-Pairs-%E5%A5%BD%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9%E5%AF%B9%E7%9A%84%E6%95%B0%E9%87%8F"><span class="toc-text">1530. Number of Good Leaf Nodes Pairs(好叶子结点对的数量)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9ABrute-Force-1"><span class="toc-text">方法一：Brute Force</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9ARecursion"><span class="toc-text">方法二：Recursion</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#662-Maximum-Width-of-Binary-Tree-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A6"><span class="toc-text">662. Maximum Width of Binary Tree(二叉树的最大宽度)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1489-Find-Critical-and-Pseudo-Critical-Edges-in-Minimum-Spanning-Tree-%E6%89%BE%E5%88%B0%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%87%8C%E7%9A%84%E5%85%B3%E9%94%AE%E8%BE%B9%E5%92%8C%E4%BC%AA%E5%85%B3%E9%94%AE%E8%BE%B9"><span class="toc-text">1489. Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree(找到最小生成树里的关键边和伪关键边)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9AKruskal-disjoint-set-union-find"><span class="toc-text">方法一：Kruskal, disjoint-set&#x2F;union-find</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1483-Kth-Ancestor-of-a-Tree-Node-%E6%A0%91%E7%BB%93%E7%82%B9%E7%9A%84%E7%AC%ACK%E4%B8%AA%E7%A5%96%E5%85%88"><span class="toc-text">1483. Kth Ancestor of a Tree Node(树结点的第K个祖先)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9ABrute-Force-2"><span class="toc-text">方法一：Brute Force</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">方法二：动态规划</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1443-Minimum-Time-to-Collect-All-Apples-in-a-Tree-%E6%94%B6%E9%9B%86%E6%A0%91%E4%B8%8A%E6%89%80%E6%9C%89%E8%8B%B9%E6%9E%9C%E7%9A%84%E6%9C%80%E5%B0%8F%E6%97%B6%E9%97%B4"><span class="toc-text">1443. Minimum Time to Collect All Apples in a Tree(收集树上所有苹果的最小时间)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9ARecursion"><span class="toc-text">方法一：Recursion</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1382-Balance-a-Binary-Search-Tree-%E5%B0%86%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%8F%98%E5%B9%B3%E8%A1%A1"><span class="toc-text">1382. Balance a Binary Search Tree(将二叉搜索树变平衡)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9AInorder-Recursion"><span class="toc-text">方法一：Inorder + Recursion</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1373-Maximum-Sum-BST-in-Binary-Tree-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E5%AD%90%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E9%94%AE%E5%80%BC%E5%92%8C"><span class="toc-text">1373. Maximum Sum BST in Binary Tree(二叉搜索子树的最大键值和)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9ARecursion-1"><span class="toc-text">方法一：Recursion</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#108-Convert-Sorted-Array-to-Binary-Search-Tree-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E5%8C%96%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">108. Convert Sorted Array to Binary Search Tree(将有序数组转化为二叉搜索树)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1339-Maximum-Product-of-Splitted-Binary-Tree-%E5%88%86%E8%A3%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF"><span class="toc-text">1339. Maximum Product of Splitted Binary Tree(分裂二叉树的最大乘积)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9ARecursion-2"><span class="toc-text">方法一：Recursion</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1305-All-Elements-in-Two-Binary-Search-Trees-%E4%B8%A4%E4%B8%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0"><span class="toc-text">1305. All Elements in Two Binary Search Trees(两个二叉搜索树中的所有元素)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9AInorder-traversal-Merge"><span class="toc-text">方法一：Inorder traversal + Merge</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1296-Divide-Array-in-Sets-of-K-Consecutive-Numbers-%E5%88%92%E5%88%86%E6%95%B0%E7%BB%84%E4%B8%BA%E8%BF%9E%E7%BB%AD%E6%95%B0%E5%AD%97%E7%9A%84%E9%9B%86%E5%90%88"><span class="toc-text">1296. Divide Array in Sets of K Consecutive Numbers(划分数组为连续数字的集合)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9AGreedy-Map"><span class="toc-text">方法一：Greedy + Map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9AHashTable-starts"><span class="toc-text">方法二：HashTable + starts</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#116-Populating-Next-Right-Pointers-in-Each-Nod-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88"><span class="toc-text">116. Populating Next Right Pointers in Each Nod(填充每个节点的下一个右侧节点指针)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">方法一：层序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9ARecursion-Pre-Order"><span class="toc-text">方法二：Recursion + Pre_Order</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1110-Delete-Nodes-And-Return-Forest-%E5%88%A0%E7%82%B9%E6%88%90%E6%9E%97"><span class="toc-text">1110. Delete Nodes And Return Forest(删点成林)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9ARecursion-3"><span class="toc-text">方法一：Recursion</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1145-Binary-Tree-Coloring-Game-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9D%80%E8%89%B2%E6%B8%B8%E6%88%8F"><span class="toc-text">1145. Binary Tree Coloring Game(二叉树着色游戏)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#979-Distribute-Coins-in-Binary-Tree-%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%88%86%E9%85%8D%E7%A1%AC%E5%B8%81"><span class="toc-text">979. Distribute Coins in Binary Tree(在二叉树中分配硬币)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9ARecursion-4"><span class="toc-text">方法一：Recursion</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#894-All-Possible-Full-Binary-Trees-%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E7%9A%84%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">894. All Possible Full Binary Trees(所有可能的满二叉树)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9ARecursion-DP"><span class="toc-text">方法一：Recursion&#x2F;DP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">105. 从前序与中序遍历序列构造二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">106. 从中序与后序遍历序列构造二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#889-Construct-Binary-Tree-from-Preorder-and-Postorder-Traversal-%E6%A0%B9%E6%8D%AE%E5%89%8D%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">889. Construct Binary Tree from Preorder and Postorder Traversal(根据前序和后序遍历构造二叉树)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9ARecursion-5"><span class="toc-text">方法一：Recursion</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#865-Smallest-Subtree-with-all-the-Deepest-Nodes-%E5%85%B7%E6%9C%89%E6%89%80%E6%9C%89%E6%9C%80%E6%B7%B1%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%90%E6%A0%91"><span class="toc-text">865. Smallest Subtree with all the Deepest Nodes(具有所有最深节点的最小子树)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9ARecursion-6"><span class="toc-text">方法一：Recursion</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#863-All-Nodes-Distance-K-in-Binary-Tree-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%80%E6%9C%89%E8%B7%9D%E7%A6%BB%E4%B8%BAK%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-text">863. All Nodes Distance K in Binary Tree(二叉树中所有距离为K的节点)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9ABuild-Graph-BFS"><span class="toc-text">方法一：Build Graph + BFS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A-Recursion"><span class="toc-text">方法二： Recursion</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#823-Binary-Trees-With-Factors-%E5%B8%A6%E5%9B%A0%E5%AD%90%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">823. Binary Trees With Factors(带因子的二叉树)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">方法一：动态规划</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#486-Predict-the-Winner-%E9%A2%84%E6%B5%8B%E8%B5%A2%E5%AE%B6"><span class="toc-text">486. Predict the Winner(预测赢家)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9ARecursion-Memorization"><span class="toc-text">方法一：Recursion + Memorization</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#450-Delete-Node-in-a-BST-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-text">450. Delete Node in a BST(删除二叉搜索树中的节点)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4%E6%96%B9%E6%B3%95"><span class="toc-text">普通二叉树的删除方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#669-%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">669. 修剪二叉搜索树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#701-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-text">701. 二叉搜索树中的插入操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#315-Count-of-Smaller-Numbers-After-Self-%E8%AE%A1%E7%AE%97%E5%8F%B3%E4%BE%A7%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-text">315. Count of Smaller Numbers After Self(计算右侧小于当前元素的个数)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9ABrute-Force-3"><span class="toc-text">方法一：Brute Force</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9AFenwick-Tree-Binary-Indexed-Tree"><span class="toc-text">方法一：Fenwick Tree&#x2F; Binary Indexed Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9ABinary-Indexed-Tree"><span class="toc-text">方法三：Binary Indexed Tree</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#297-Serialize-and-Deserialize-Binary-Tree-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">297. Serialize and Deserialize Binary Tree(二叉树的序列化与反序列化)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9ARecursion-string"><span class="toc-text">方法一：Recursion + string</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9ARecursion-Binary"><span class="toc-text">方法二：Recursion + Binary</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#449-Serialize-and-Deserialize-BST-%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">449. Serialize and Deserialize BST(序列化和反序列化二叉搜索树)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9ARecursion-7"><span class="toc-text">方法一：Recursion</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#652-Find-Duplicate-Subtrees-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E6%A0%91"><span class="toc-text">652. Find Duplicate Subtrees(寻找重复的子树)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A-1"><span class="toc-text">方法一：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A"><span class="toc-text">方法二：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#742-Closest-Leaf-in-a-Binary-Tree-%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E8%BF%91%E7%9A%84%E5%8F%B6%E8%8A%82%E7%82%B9"><span class="toc-text">742. Closest Leaf in a Binary Tree(二叉树最近的叶节点)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9ABFS"><span class="toc-text">方法一：BFS</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#745-Prefix-and-Suffix-Search-%E5%89%8D%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E6%90%9C%E7%B4%A2"><span class="toc-text">745. Prefix and Suffix Search(前缀和后缀搜索)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9Ahashtable"><span class="toc-text">方法一：hashtable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9ATrie"><span class="toc-text">方法二：Trie</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#530-Minimum-Absolute-Difference-in-BST-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE"><span class="toc-text">530. Minimum Absolute Difference in BST(二叉搜索树的最小绝对差)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9AInorder"><span class="toc-text">方法一：Inorder</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#98-Validate-Binary-Search-Tree"><span class="toc-text">98. Validate Binary Search Tree</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9AInorder-1"><span class="toc-text">方法一：Inorder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="toc-text">方法二：贪心算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#257-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84"><span class="toc-text">257. 二叉树的所有路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9F"><span class="toc-text">递归函数是否需要有返回值？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-text">二叉树的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E3%80%81%E5%90%8E%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">二叉树的前序、后序、中序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">二叉树的层序遍历</span></a></li></ol></li></ol>
  </aside>

        
      </div>
    </div>
  </div>
</main>
  

<footer class="footer">
  <div class="footer-social"><a 
        href="tencent://message/?Menu=yes&uin=2274849184 "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#12B7F5'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconQQ "></i>
      </a><a 
        href="javascript:; "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#09BB07'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconwechat-fill "></i>
      </a><a 
        href="https://www.instagram.com/xxdsh/ "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#DA2E76'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconinstagram "></i>
      </a><a 
        href="https://github.com/xxdsh "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#9f7be1'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  icongithub-fill "></i>
      </a><a 
        href="mailto:mychen@buaa.edu.cn "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color=#FF3B00" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconmail"></i>
      </a></div>
  
    <div class="footer-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Cure The World </p></div>
  
</footer>
  
      <div class="fab fab-plus">
    <i class="iconfont iconplus"></i>
  </div>
  
  
  <div class="fab fab-up">
    <i class="iconfont iconcaret-up"></i>
  </div>
  
  
  
    
<script src="/js/color-mode.js"></script>

  
  
    <div class="search">
  <div class="search-container">
    <div class="search-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <div class="search-input-wrapper">
      <i class="search-input-icon iconfont iconsearch"></i>
      <input class="search-input" type="search" id="search-input" placeholder="Search..." autofocus autocomplete="off"
        autocorrect="off" autocapitalize="off">
    </div>
    <div class="search-output" id="search-output"></div>
  </div>
</div>
  
</body>

<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>



  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script>




  
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script>






  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.qrcode/1.0/jquery.qrcode.min.js"></script>




<script src="/js/utils.js"></script>
<script src="/js/script.js"></script>







  <script>
    (function () {
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      } else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>













</html>