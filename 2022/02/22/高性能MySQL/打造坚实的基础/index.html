

<!DOCTYPE html>
<html lang="en" color-mode=light>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>打造坚实的基础 - XXDSHZJ</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="google" content="notranslate" />
  
  <meta name="description" content="第二章 MySQL基准测试基准测试是针对系统设计的一种...">
  <meta name="author" content="Mengyuan Chen">
  <link rel="icon" href="/images/icons/favicon-16x16.png" type="image/png" sizes="16x16">
  <link rel="icon" href="/images/icons/favicon-32x32.png" type="image/png" sizes="32x32">
  <link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png" sizes="180x180">
  <meta rel="mask-icon" href="/images/icons/stun-logo.svg" color="#333333">
  
    <meta rel="msapplication-TileImage" content="/images/icons/favicon-144x144.png">
    <meta rel="msapplication-TileColor" content="#000000">
  

  
<link rel="stylesheet" href="/css/style.css">


  
    
<link rel="stylesheet" href="//at.alicdn.com/t/font_1445822_r673sha78lq.css">

  

  
    
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css">

  

  
    
      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/xcode.min.css" name="highlight-style" mode="light">

      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/solarized-dark.min.css" name="highlight-style" mode="dark">

      
  

  <script>
    var CONFIG = window.CONFIG || {};
    var ZHAOO = window.ZHAOO || {};
    CONFIG = {
      isHome: false,
      fancybox: true,
      pjax: false,
      lazyload: {
        enable: true,
        only_post: 'false',
        loading: '[object Object]'
      },
      donate: {
        enable: true,
        alipay: 'https://sm.ms/image/Y6TiL7UgNHm2RSl',
        wechat: 'https://sm.ms/image/aklIG9KSHPFcV8n'
      },
      galleries: {
        enable: true
      },
      fab: {
        enable: true,
        always_show: false
      },
      carrier: {
        enable: true
      },
      daovoice: {
        enable: false
      },
      preview: {
        background: {
          default: '',
          api: ''
        },
        motto: {
          default: '我在开了灯的床头下，想问问自己的心啊。',
          typing: true,
          api: 'https://v2.jinrishici.com/one.json',
          data_contents: '["data","content"]'
        },
      },
      qrcode: {
        enable: true,
        type: 'url',
        image: 'https://pic.izhaoo.com/weapp-code.jpg',
      },
      toc: {
        enable: true
      },
      scrollbar: {
        type: 'default'
      },
      notification: {
        enable: false,
        delay: 4500,
        list: '',
        page_white_list: '',
        page_black_list: ''
      },
      search: {
        enable: true,
        path: '/search.xml'
      }
    }
  </script>

  

  

<meta name="generator" content="Hexo 5.4.0"></head>

<body class="lock-screen">
  <div class="loading"></div>
  
    


  <nav class="navbar">
    <div class="left">
      
        <i class="iconfont iconhome j-navbar-back-home"></i>
      
      
        <i class="iconfont iconqrcode j-navbar-qrcode"></i>
      
      
        <i class="iconfont iconmoono" id="color-toggle" color-toggle="light"></i>
      
      
        <i class="iconfont iconsearch j-navbar-search"></i>
      
    </div>
    <div class="center">打造坚实的基础</div>
    <div class="right">
      <i class="iconfont iconmenu j-navbar-menu"></i>
    </div>
    
      <div id="qrcode-navbar"></div>
    
  </nav>

  
  

<nav class="menu">
  <div class="menu-container">
    <div class="menu-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <ul class="menu-content"><li class="menu-item">
        <a href="/ " class="underline "> 首页</a>
      </li><li class="menu-item">
        <a href="/galleries/ " class="underline "> 相册</a>
      </li><li class="menu-item">
        <a href="/archives/ " class="underline "> 归档</a>
      </li><li class="menu-item">
        <a href="/tags/ " class="underline "> 标签</a>
      </li><li class="menu-item">
        <a href="/categories/ " class="underline "> 分类</a>
      </li><li class="menu-item">
        <a href="/about/ " class="underline "> 关于</a>
      </li></ul>
    
      <div class="menu-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Cure The World </p></div>
    
  </div>
</nav>
  <main id="main">
  <div class="article-wrap">
    <div class="row container">
      <div class="col-xl-3"></div>
      <div class="col-xl-6"><article class="article">
  <div class="wrap">
    <section class="head">
  <img   class="lazyload" data-original="/images/theme/%E5%8F%AF%E7%88%B1%E6%97%A0%E6%B3%95%E5%A4%8D%E5%88%B6/img-6.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  draggable="false">
  <div class="head-mask">
    <h1 class="head-title">打造坚实的基础</h1>
    <div class="head-info">
      <span class="post-info-item"><i class="iconfont iconcalendar"></i>February 22, 2022</span>
      
      <span class="post-info-item"><i class="iconfont iconfont-size"></i>13161</span>
    </div>
  </div>
</section>
    <section class="main">
      <section class="content">
        <h3 id="第二章-MySQL基准测试"><a href="#第二章-MySQL基准测试" class="headerlink" title="第二章 MySQL基准测试"></a>第二章 MySQL基准测试</h3><p>基准测试是针对系统设计的一种压力测试</p>
<h4 id="2-1-为什么需要基准测试"><a href="#2-1-为什么需要基准测试" class="headerlink" title="2.1 为什么需要基准测试"></a>2.1 为什么需要基准测试</h4><p>基准测试是唯一方便有效的、可以学习系统在给定的工作负载下会发生什么的方法。<br>基准测试可以观察系统在不同压力下的行为，评估系统的容量，掌握哪些是重要的变化，或者观察系统如何处理不同的数据。<br>有很多因素会影响基准测试，比如数据量、数据和查询的分布，但最重要的一点还是基准测试通常要求尽可能快地执行完成，所以经常给系统造成过大的压力。</p>
<h4 id="2-2-基准测试的策略"><a href="#2-2-基准测试的策略" class="headerlink" title="2.2 基准测试的策略"></a>2.2 基准测试的策略</h4><p>一是针对整个系统的整体测试，另外是单独测试MySQL<br>集成式(full-stack)以及单组件式(single-component)基准测试<br>测试目标决定了选择什么样的测试工具和技术，以获得精确而有意义的测试结果<br>吞吐量指的是单位时间内的事务处理数。<br>在线事务处理(OLTP)的吞吐量<br>每秒事务数(TPS)，有些也采用每分钟事务数(TPM)。<br>响应时间或者延迟用于测试任务所需的整体时间。<br>测试的时间单位可能是微秒、毫秒、秒或者分钟。<br>平均响应时间、最小响应时间、最大响应时间和所占百分比<br>并发性是一个非常重要又经常被误解和误用的指标。<br>在任意时间有多少同时发生的并发请求。<br>并发性基准测试需要关注的是正在工作中的并发操作，或者是同时工作中的线程数或者连接数。<br>可扩展性:给系统增加一倍的工作，在理想情况下就能获得两倍的结果(即吞吐量增加一倍)。或者说，给系统增加一倍的资源(比如两倍的CPU数)，就可以获得两倍的吞吐量。</p>
<h4 id="2-3-基准测试方法"><a href="#2-3-基准测试方法" class="headerlink" title="2.3 基准测试方法"></a>2.3 基准测试方法</h4><p>规划基准测试的第一步是提出问题并明确目标。然后决定是采用标准的基准测试，还是设计专用的测试。<br>基准测试应该运行足够长的时间<br>在执行基准测试时，需要尽可能多地收集被测试系统的信息。<br>测试结果、配置文件、测试指标、脚本和其他相关说明<br>系统状态和性能指标，诸如CPU使用率、磁盘I/O、网络流量统计、SHOwGLOBAL STATUS计数器等。<br>确认测试结果是否可重复。<br>一个确保物理磁盘数据的分布尽可能一致的办法是，每次都进行快速格式化并进行磁盘分区复制。<br>外部的压力、性能分析和监控系统、详细的日志记录、周期性作业，以及其他一些因素，都会影响到测试结果。<br>要确保基准测试运行过程中所需要的资源是专用于测试的。如果有其他额外的操作，则会消耗网络带宽，或者测试基于的是和其他服务器共享的SAN存储，那么得到的结果很可能是不准确的。<br>自动化的方式:一个Makefile文件或者一组脚本。<br>装载数据、系统预热、执行测试、记录结果等。</p>
<h4 id="2-4-基准测试工具"><a href="#2-4-基准测试工具" class="headerlink" title="2.4 基准测试工具"></a>2.4 基准测试工具</h4><p>集成式测试工具: ab; http_load; JMeter<br>单组件式测试工具: mysqlslap; MySQL Benchmark Suite(sql-bench); Super Smack; Database Test Suite; Percona’s TPCC-MySQL Tool; sysbench<br>MySQL有一个内置的BENCHMARK()函数，可以测试某些特定操作的执行速度。</p>
<h4 id="2-5基准测试案例"><a href="#2-5基准测试案例" class="headerlink" title="2.5基准测试案例"></a>2.5基准测试案例</h4><p>MySQL基准测试套件(MySQL Benchmark Suite)由一组基于Perl开发的基准测试工具组成。<br>sq1-bench$ ./run-all -tests –server=mysql –user=root –1og –fast</p>
<h3 id="第三章-服务器性能剖析"><a href="#第三章-服务器性能剖析" class="headerlink" title="第三章 服务器性能剖析"></a>第三章 服务器性能剖析</h3><p>如何确认服务器是否达到了性能最佳的状态、找出某条语句为什么执行不够快,以及诊断被用户描述成“停顿”、“堆积”或者“卡死”的某些间歇性疑难故障。<br>专注于测量服务器的时间花费在哪里，使用的技术是性能剖析(profiling)。</p>
<h4 id="3-1-性能优化简介"><a href="#3-1-性能优化简介" class="headerlink" title="3.1 性能优化简介"></a>3.1 性能优化简介</h4><p>性能：完成某件任务所需要的时间度量<br>无法测量就无法有效地优化。<br>合适的测量范围是说只测量需要优化的活动。<br>有两种比较常见的情况会导致不合适的测量:在错误的时间启动和停止测量。测量的是聚合后的信息，而不是目标活动本身。<br>完成一项任务所需要的时间可以分成两部分:执行时间和等待时间。<br>性能剖析是测量和分析时间花费在哪里的主要方法。一般有两个步骤:测量任务所花费的时间;然后对结果进行统计和排序，将重要的任务排到前面。<br>性能剖析报告会列出所有任务列表。每行记录一个任务，包括任务名、任务的执行时间、任务的消耗时间、任务的平均执行时间，以及该任务执行时间占全部时间的百分比。<br>性能剖析报告会按照任务的消耗时间进行降序排序。<br>两种类型的性能剖析:基于执行时间的分析和基于等待的分析。<br>值得优化的查询(worthwhile query); 异常情况; 未知的未知; 被掩藏的细节</p>
<h4 id="3-2-对应用程序进行性能剖析"><a href="#3-2-对应用程序进行性能剖析" class="headerlink" title="3.2 对应用程序进行性能剖析"></a>3.2 对应用程序进行性能剖析</h4><p>外部资源; 应用需要处理大量的数据; 在循环中执行昂贵的操作; 使用了低效的算法，<br>性能剖析和定期检测都会带来额外开销。问题在于这部分的开销有多少，并且由此获得的收益是否能够抵消这些开销。<br>New Relic的软件即服务(software-as-<br>a-service)产品: NewRelic会插入到应用程序中进行性能剖析，将收集到的数据发送到一个基于Web的仪表盘，使用仪表盘可以更容易利用面向响应时间的方法分析应用性能。<br>xhprof Ifp MySQL的企业监控器(Enterprise Monitor)</p>
<h4 id="3-3-剖析MySQL查询"><a href="#3-3-剖析MySQL查询" class="headerlink" title="3.3 剖析MySQL查询"></a>3.3 剖析MySQL查询</h4><p>剖析服务器负载<br>捕获MySQL的查询到日志文件中<br>慢查询日志是开销最低、精度最高的测量查询时间的工具<br>分析查询日志<br>pt-query-digest：分析MySQL查询日志最有力的工具。可以将查询报告保存到数据库中，以及追踪工作负载随时间的变化。<br>SHOW STATUS、 SHOW PROFILE、检查慢查询日志的条<br>目 剖析单条查询<br>SHOW PROFILES; SHOW PROFILE FOR QUERY 1;<br>SHOW STATUS是一个有用的工具,但并不是一款剖析工具<br>SHOW STATUS的大部分结果都只是一个计数器，可以显示某些活动如读索引的频繁程度，但无法给出消耗了多少时<br>间。SHOW STATUS的结果中只有一条指的是操作的时间(Innodb_row_lock_time)，而且只能是全局级的，所以还是无法测量会话级别的工作。<br>句柄计数器(handler counter)、临时文件和表计数器</p>
<h4 id="3-4-诊断间歇性问题"><a href="#3-4-诊断间歇性问题" class="headerlink" title="3.4 诊断间歇性问题"></a>3.4 诊断间歇性问题</h4><p>间歇性的问题比如系统偶尔停顿或者慢查询，很难诊断。<br>使用SHOW GLOBAL STATUS<br>通过某些计数器(比如Threads_running、 Threads_connected、Questions和Queries)的“尖刺”或者“凹陷”来发现。<br>使用SHOW PROCESSLIST<br>使用查询日志<br>理解发现的问题(Making sense of the findings)<br>一个可靠且实时的“触发器”，也就是能区分什么时候问题出现的方法。一个收集诊断数据的工具。<br>误报(false positive)或者漏检(false negative)</p>
<h4 id="3-5-其他剖析工具"><a href="#3-5-其他剖析工具" class="headerlink" title="3.5 其他剖析工具"></a>3.5 其他剖析工具</h4><p>使用USER_STATISTICS 表<br>使用strace</p>
<h3 id="第4章-Schema与数据类型优化"><a href="#第4章-Schema与数据类型优化" class="headerlink" title="第4章 Schema与数据类型优化"></a>第4章 Schema与数据类型优化</h3><p>良好的逻辑设计和物理设计是高性能的基石，应该根据系统将要执行的查询语句来设计schema,这往往需要权衡各种因素。<br>逻辑设计、物理设计和查询执行，以及它们之间的相互作用。</p>
<h4 id="4-1-选择优化的数据类型"><a href="#4-1-选择优化的数据类型" class="headerlink" title="4.1 选择优化的数据类型"></a>4.1 选择优化的数据类型</h4><p>MySQL支持的数据类型非常多，选择正确的数据类型对于获得高性能至关重要。<br>更小的通常更好; 简单就好; 尽量避免NULL<br>确定合适的大类型:数字、字符串、时间等; 选择具体类型<br>很多MySQL的数据类型可以存储相同类型的数据，只是存储<br>的长度和范围不-样、允许的精度不同，或者需要的物理空间(磁盘和内存空间)不同。<br>相<br>有两种类型的数字:整数(whole number)和实数(real number)。如果存储整数，可以使用这几种整数类型: TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT。分别使用8, 16, 24, 32, 64位存储空间。整数类型有可选的UNSIGNED属性，表示不允许负值<br>可以为整数类型指定宽度，例如INT(11):它不会限制值的合法范围,只是规定了MySQL的一些交互工具(例如MySQL命令行客户端)用来显示字符的个数。<br>实数是带有小数部分的数字。然而，它们不只是为了存储小数部分;也可以使用DECIMAL存储比BIGINT还大的整数。MySQL既支持精确类型，也支持不精确类型。<br>FL0AT和DOUBLE类型 DECIMAL类型<br>字符集和排序规则，或者说校对规则(collation)<br>VARCHAR和CHAR类型 BINARY和VARBINARY(二进制字符串存储的是字节码而不是字符)<br>BLOB和TEXT都是为存储很大的数据而设计的字符串数据类型，分别采用二进制和字符方式存储。<br>字符类型是TINYTEXT, SMALLTEXT, TEXT，MEDIUMTEXT，LONGTEXT ;<br>对应的二进制类型是TINYBLOB，SMALLBLOB，BLOB, MEDIUMBLOB，LONGBLOB。<br>使用枚举(ENUM)代替字符串类型<br>DATETIME和TIMESTAMP<br>位数据类型: BIT SET 在整数列上进行按位操作</p>
<h4 id="4-2-MySQL-schema设计中的陷阱"><a href="#4-2-MySQL-schema设计中的陷阱" class="headerlink" title="4.2 MySQL schema设计中的陷阱"></a>4.2 MySQL schema设计中的陷阱</h4><p>太多的列; 太多的关联; 全能的枚举; 变相的枚举; 非此发明(Not Invent Here)的NULL</p>
<h4 id="4-3-范式和反范式"><a href="#4-3-范式和反范式" class="headerlink" title="4.3 范式和反范式"></a>4.3 范式和反范式</h4><p>范式化的更新操作通常比反范式化要快; 当数据较好地范式化时，就只有很少或者没有重复数据,所以只需要修改更少的数据; 范式化的表通常更小，可以更好地放在内存里，所以执行操作会更快; 很少有多余的数据意味着检索列表数据时更少需要DISTINCT或者GROUPBY语句。<br>范式化设计的schema的缺点是通常需要关联。</p>
<h4 id="4-4-缓存表和汇总表"><a href="#4-4-缓存表和汇总表" class="headerlink" title="4.4 缓存表和汇总表"></a>4.4 缓存表和汇总表</h4><p>术语“缓存表”表示存储那些可以比较简单地从schema其他表获取(但是每次获取的速度比较慢)数据的表(例如，<br>逻辑上冗余的数据)。<br>术语“汇总表”保存的是使用GROUPBY语句聚合数据的表(例如，数据不是逻辑上冗余的)。<br>在使用缓存表和汇总表时，必须决定是实时维护数据还是定期重建。<br>物化视图实际上是预先计算并且存储在磁盘上的表，可以通过各种各样的策略刷新和更新。</p>
<h4 id="4-5-加快ALTER-TABLE操作的速度"><a href="#4-5-加快ALTER-TABLE操作的速度" class="headerlink" title="4.5 加快ALTER TABLE操作的速度"></a>4.5 加快ALTER TABLE操作的速度</h4><p>一种是先在一台不提供服务的机器上执行ALTER TABLE操作，然后和提供服务的主库进行切换;另外一种技巧是“影子拷贝”。<br>直接修改.frm文件<br>FLUSH TABLES WITH READ LOCK; 交换.frm文件; UNLOCK TABLES;<br>快速创建MyISAM索引:为了高效地载人数据到MyISAM表中，有一个常用的技巧是先禁用索引、载入数据，然后重新启用索引</p>
<h3 id="第5章-创建高性能的索引"><a href="#第5章-创建高性能的索引" class="headerlink" title="第5章 创建高性能的索引"></a>第5章 创建高性能的索引</h3><p>索引(在MySQL中也叫做“键(key)”)是存储引擎用于快速找到记录的一种数据结构。</p>
<h4 id="5-1-索引基础"><a href="#5-1-索引基础" class="headerlink" title="5.1 索引基础"></a>5.1 索引基础</h4><p>在MySQL中，索引是在存储引擎层而不是服务器层实现的。<br>B-Tree索引<br>B-Tree 索引适用于全键值、键值范围或键前缀查找。其中键前缀查找只适用于根据最左前缀的查找生了。<br>全值匹配；匹配最左前缀；匹配列前缀；匹配范围值；精确匹配某一列并范围匹配另外一列；只访问索引的查询<br>如果B-Tree可以按照某种方式查找到值，那么也可以按照这种方式用于排序。<br>在优化性能的时候，可能需要使用相同的列但顺序不同的索引来满足不同类型的查询需求。<br>哈希索引(hashindex)基于哈希表实现，只有精确匹配索引所有列的查询才有效<br>InnoDB引擎有一个特殊的功能叫做“自适应哈希索引(adaptive hash index)”。<br>空间数据索引(R-Tree)：无须前缀查询。空间索引会从所有维度来索引数据。查询时，可以有效地使用任意维度来<br>组合查询。<br>全文索引：一种特殊类型的索引，它查找的是文本中的关键词，而不是直接比较索引中的值。</p>
<h4 id="5-2-索引的优点"><a href="#5-2-索引的优点" class="headerlink" title="5.2 索引的优点"></a>5.2 索引的优点</h4><p>索引可以让服务器快速地定位到表的指定位置。但是这并不是索引的唯一作用<br>B-Tree索引，按照顺序存储数据，所以MySQL可以用来做ORDER BY和GROUP BY操作。因为数据是有序的，所以B-Tree也就会将相关的列值都存储在一起。最后，因为索引中存储了实际的列值，所以某些查询只使用索引就能够完成全部查询。<br>1.索引大大减少了服务器需要扫描的数据量。<br>2.索引可以帮助服务器避免排序和临时表。<br>3.索引可以将随机I/O变为顺序I/O。<br>索引将相关的记录放到一起则获得一星;如果索引中的数据顺序和查找中的排列顺序一致则获得二星;如果索引中的列包含了查询中需要的全部列则获得“三星”。</p>
<h4 id="5-3-高性能的索引策略"><a href="#5-3-高性能的索引策略" class="headerlink" title="5.3 高性能的索引策略"></a>5.3 高性能的索引策略</h4><p>“独立的列”是指索引列不能是表达式的一部分，也不能是函数的参数。<br>可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。但这样也会降低索引的选择性。索引的选择性是指，不重复的索引值(也称为基数，cardinality)和数据表的记录总数(#T)的比值，范围从1/#T到1之间。<br>诀窍在于要选择足够长的前缀以保证较高的选择性，同时又不能太长(以便节约空间)。<br>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。<br>术语“聚簇”表示数据行和相邻的键值紧凑地存储在一起。<br>覆盖索引: 如果一个索引包含(或者说覆盖)所有需要查询的字段的值，我们就称之为“覆盖索引”。<br>MySQL有两种方式可以生成有序的结果:通过排序操作;或者按索引顺序扫描<br>只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向(倒序或正序)都一样时，MySQL才能够使用索引来对结果做排序<br>压缩(前缀压缩)索引：压缩块使用更少的空间，代价是某些操作可能更慢。<br>冗余和重复索引：重复索引是指在相同的列.上按照相同的顺序创建的相同类型的索引。<br>找出冗余和重复索引：可以通过写一些复杂的访问INFORMATION_ SCHEMA 表的查询来找； 可使用Shlomi Noach的common_schema中的一些视图来定位,common_ schema是一系列可以安装到服务器上的常用的存储和视图；可以使用Percona Tolkit中的pt-duplicate-key-checker，该工具通过分析表结构来找出冗余和重复的索引。<br>未使用的索引：在Percona Server或者MariaDB中先打开userstates服务器变量( 默认是关闭的)，然后让服务器正常运行一段时间，再通过查询INFORMATION_SCHEMA. INDEX_STATISTICS 就<br>能查到每个索引的使用频率。另外，还可以使用Percona Toolkit中的pt-index-usage，该工具可以读取查询日志，并对日志中的每条查询进行EXPLAIN操作，然后打印出关于索引和查询的报告。<br>索引和锁：索引可以让查询锁定更少的行。</p>
<h4 id="5-4-索引案例学习"><a href="#5-4-索引案例学习" class="headerlink" title="5.4 索引案例学习"></a>5.4 索引案例学习</h4><h4 id="5-5-维护索引和表"><a href="#5-5-维护索引和表" class="headerlink" title="5.5 维护索引和表"></a>5.5 维护索引和表</h4><p>找到并修复损坏的表；维护准确的索引统计信息；减少碎片<br>CHECK TABLE； REPAIR TABLE;<br>了解存储引擎的索引值的分布信息，以决定如何使用索引：records_in_range():通过向存储引擎传入两个边界值获取在这个范围内大概有多少条记录。info():返回各种类型的数据，包括索引的基数(每个键值有多少条记录)<br>SHOW INDEX FROM table_name;<br>数据碎片：行碎片(Row fragmentation); 行间碎片(Intra-row fragmentation); 剩余空间碎片(free space fragmentation)</p>
<h3 id="第六章-查询性能优化"><a href="#第六章-查询性能优化" class="headerlink" title="第六章 查询性能优化"></a>第六章 查询性能优化</h3><p>查询优化 索引优化 库表结构优化</p>
<h4 id="6-1-为什么查询速度会慢"><a href="#6-1-为什么查询速度会慢" class="headerlink" title="6.1 为什么查询速度会慢"></a>6.1 为什么查询速度会慢</h4><p>通常来说，查询的生命周期大致可以按照顺序来看:从客户端，到服务器，然后在服务器上进行解析，生成执行计划，执行，并返回结果给客户端。</p>
<h4 id="6-2-慢查询基础-优化数据访问"><a href="#6-2-慢查询基础-优化数据访问" class="headerlink" title="6.2 慢查询基础:优化数据访问"></a>6.2 慢查询基础:优化数据访问</h4><p>查询性能低下最基本的原因是访问的数据太多。某些查询可能不可避免地需要筛选大量数据，但这并不常见。大部分性能低下的查询都可以通过减少访问的数据量的方式进行优化。<br>1．确认应用程序是否在检索大量超过需要的数据。<br>2．确认MySQL服务器层是否在分析大量超过需要的数据行<br>查询不需要的记录；多表关联时返回全部列； 总是取出全部列； 重复查询相同的数据<br>最简单的衡量查询开销的三个指标如下:响应时间;扫描的行数和返回的行数；扫描的行数和访问类型<br>响应时间 = 服务时间 + 排队时间。<br>服务时间是指数据库处理这个查询真正花了多长时间。排队时间是指服务器因为等待某些资源而没有真正执行查询的时间——可能是等I/О操作完成，也可能是等待行锁，等等<br>可以使用“快速上限估计”法来估算查询的响应时间。<br>在EXPLAIN语句中的type列反应了访问类型。访问类型有很多种，从全表扫描到索引扫描、范围扫描、唯一索引查询、常数引用等。<br>一般MySQL能够使用如下三种方式应用WHERE条件，从好到坏依次为:[在索引中使用WHERE条件来过滤不匹配的记录。这是在存储引擎层完成的。] [使用索引覆盖扫描(在Extra列中出现了Using index)来返回记录，直接从索引中过滤不需要的记录并返回命中的结果。这是在MySQL服务器层完成的，但无须再回表查询记录。] [从数据表中返回数据，然后过滤不满足条件的记录(在Extra列中出现Using Where)。这在MySQL服务器层完成，MySQL需要先从数据表读出记录然后过滤。]</p>
<h4 id="6-3-重构查询的方式"><a href="#6-3-重构查询的方式" class="headerlink" title="6.3 重构查询的方式"></a>6.3 重构查询的方式</h4><p>一个复杂查询还是多个简单查询；切分查询；分解关联查询</p>
<h3 id="6-4-查询执行的基础"><a href="#6-4-查询执行的基础" class="headerlink" title="6.4 查询执行的基础"></a>6.4 查询执行的基础</h3><p>很多查询优化工作实际上就是遵循一些原则让优化器能够按照预想的合理的方式运行。<br><img    class="lazyload" data-original="https://s2.loli.net/2022/02/17/zPOI361K8uXQ2go.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="    style="zoom:50%;" /><span class="image-caption">查询执行路径</span><br>MySQL客户端/服务器通信协议:MySQL客户端和服务器之间的通信协议是“半双工”的<br>查看当前的状态，最简单的是使用SHOw FULLPROCESSLIST命令（该命令返回结果中的Command列就表示当前的状态)。<br>查询状态：Sleep； Query； Locked； Analyzing and statistics； Copying to tmp table [on disk]； Sorting result； Sending data<br>查询缓存<br>查询优化处理：将一个SQL转换成一个执行计划，MySQL再依照这个执行计划和存储引擎进行交互。<br>包括多个子阶段:解析SQL、预处理、优化SQL执行计划。<br>语法解析器和预处理；查询优化器<br>MySQL使用基于成本的优化器，它将尝试预测一个查询使用某种执行计划时的成本，并选择其中成本最小的一个。<br>SHOW STATUS LIKE ‘Last_query_cost’;<br>根据一系列的统计信息计算:每个表或者索引的页面个数、索引的基数(索引中不同值的数量)、索引和数据行的长度、索引分布情况。<br>统计信息不准确。执行计划中的成本估算不等同于实际执行的成本。MySQL的最优可能和你想的最优不一样。MySQL从不考虑其他并发执行的查询.MySQL也并不是任何时候都是基于成本的优化。MySQL不会考虑不受其控制的操作的成本。优化器有时候无法去估算所有可能的执行计划<br>优化策略可以简单地分为两种，一种是静态优化，一种是动态优化。静态优化可以直接对解析树进行分析，并完成优化。动态优化则和查询的上下文有关，也可能和很多其他因素有关。<br>重新定义关联表的顺序；将外连接转化成内连接；使用等价变换规则；优化COUNT()、MIN()和MAX()；预估并转化为常数表达式；覆盖索引扫描；子查询优化；提前终止查询；等值传播；列表IN()的比较<br>MySQL对任何关联都执行嵌套循环关联操作，即MySQL先在一个表中循环取出单条数据，然后再嵌套循环到下一个表中寻找匹配的行，依次下去，直到找到所有表中匹配的行为止。然后根据各个表匹配的行，返回查询中需要的各个列。<br>排序：两次传输排序；单次传输排序</p>
<h4 id="6-5-MySQL查询优化器的局限性"><a href="#6-5-MySQL查询优化器的局限性" class="headerlink" title="6.5 MySQL查询优化器的局限性"></a>6.5 MySQL查询优化器的局限性</h4><p>关联子查询；UNION的限制；索引合并优化；等值传递；并行执行(MySQL无法利用多核特性来并行执行查询)；哈希关联；松散索引扫描；最大值和最小值优化；在同一个表上查询和更新；</p>
<h4 id="6-6-查询优化器的提示-hint"><a href="#6-6-查询优化器的提示-hint" class="headerlink" title="6.6 查询优化器的提示(hint)"></a>6.6 查询优化器的提示(hint)</h4><p>HIGH_PRIORITY和LOw_PRIORITY：只对使用表锁的存储引擎有效，千万不要在InnoDB或者其他有细粒度锁机制和并发控制的引擎中使用。<br>DELAYED：对INSERT和REPLACE有效。<br>STRAIGHT_JOIN：可以放置在SELECT语句的SELECT关键字之后，也可以放置在任何两个联表关的名字之间。<br>SQL_SMALL_RESULT和SQL_BIG_RESULT：只对SELECT语句有效。<br>SQL_BUFFER_RESULT：告诉优化器将查询结果放入到一个临时表，然后尽可能快地释放表锁。<br>SQL_CACHE和 SQL_NO_CACHE：告诉MySQL这个结果集是否应该缓存在查询缓存中<br>SQL_CALC_FOUND_ROWS：会让MySQL返回的结果集包含更多的信息。<br>FOR UPDATE和LOCK IN SHARE MODE： 主要控制SELECT语句的锁机制，但只对实现了行级锁的存储引擎有效。<br>USE INDEX、IGNORE INDEX和FORCE INDEX：告诉优化器使用或者不使用哪些索引来查询记录(例如，在决定关联顺序的时候使用哪个索引)<br>optimizer_search_depth；optimizer_prune_level；optimizer_switch</p>
<h4 id="6-7-优化特定类型的查询"><a href="#6-7-优化特定类型的查询" class="headerlink" title="6.7 优化特定类型的查询"></a>6.7 优化特定类型的查询</h4><p>优化COUNT()查询<br>可以统计某个列值的数量，也可以统计行数。<br>SELECT SUM(IF(color = ‘blue’, 1, 0)) As blue,SUN(IF(color = ‘red’, 1, 0)) AS red FROM items;<br>SELECT COUNT(color = ‘blue’ OR NULL) AS blue,COUNT(color = ‘red’ OR NULL) AS red FROM items;<br>执行EXPLAIN并不需要真正地去执行查询，所以成本很低。<br>“快速，精确和实现简单”，三者永远只能满足其二，必须舍掉其中一个。<br>在MySQL中，当无法使用索引的时候，GROUPBY使用两种策略来完成:使用临时表或者文件排序来做分组。<br>SELECT后面出现的非分组列一定是直接依赖分组列，并且在每个组内的值是唯一的，或者是业务上根本不在乎这个值具体是什么<br>Percona Toolkit中的pt-query-advisor能够解析查询日志、分析查询模式，然后给出所有可能存在潜在问题的查询，并给出足够详细的建议。</p>
<h4 id="6-8-案例学习"><a href="#6-8-案例学习" class="headerlink" title="6.8 案例学习"></a>6.8 案例学习</h4><p>优化通常都需要三管齐下:不做、少做、快速地做。</p>
<h3 id="第七章-MySQL高级特性"><a href="#第七章-MySQL高级特性" class="headerlink" title="第七章 MySQL高级特性"></a>第七章 MySQL高级特性</h3><h4 id="7-1-分区表"><a href="#7-1-分区表" class="headerlink" title="7.1 分区表"></a>7.1 分区表</h4><p>对用户来说，分区表是一个独立的逻辑表，但是底层由多个物理子表组成。<br>实现分区的代码实际上是对一组底层表的句柄对象(Handler Object)的封装。<br>对分区表的请求，都会通过句柄对象转化成对存储引擎的接口调用。<br>MySQL实现分区表的方式——对底层表的封装—意味着索引也是按照分区的子表定义的，而没有全局索引。<br>MySQL在创建表时使用PARTITION BY子句定义每个分区存放的数据。<br>查询都能够过滤(prunning)掉很多额外的分区、分区本身假设：并不会带来很多额外的代价。<br>NULL值会使分区过滤无效；分区列和索引列不匹配；选择分区的成本可能很高；打开并锁住所有底层表的成本可能很高；维护分区的成本可能很高<br>即便在创建分区时可以使用表达式，但在查询时却只能根据列来过滤分区。</p>
<h4 id="7-2-视图"><a href="#7-2-视图" class="headerlink" title="7.2 视图"></a>7.2 视图</h4><p>视图本身是一个虚拟表，不存放任何数据。<br>不能对视图创建触发器，也不能使用DROP TABLE命令删除视图。<br><img    class="lazyload" data-original="https://s2.loli.net/2022/02/17/LNcIjXOYl7wid3g.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="    style="zoom:50%;" /><span class="image-caption">视图的两种实现</span><br>合并算法(MERGE)和临时表算法（TEMPTABLE)注4，<br>可以在EXPLAIN<br>EXTENDED之后使用SHOW WARNINGS来查看使用视图的查询重写后的结果。<br>视图的实现算法是视图本身的属性，和作用在视图上的查询语句无关。可以为一个基于简单查询的视图指定使用临时表算法:<br>CREATE ALGORITHM=TEMPTABLE VIEW v1 AS SELECT * FROM sakila.actor;<br>可更新视图(updatable view)是指可以通过更新这个视图来更新视图涉及的相关表<br>如果视图定义中包含了GROUP BY、UNION、聚合函数，以及其他一些特殊情况，就不能被更新了。<br>MySQL还不支持物化视图（物化视图是指将视图结果数据存放在一个可以查看的表中，并定期从原始表中刷新数据到这个表中)。</p>
<h4 id="7-3-外键约束"><a href="#7-3-外键约束" class="headerlink" title="7.3 外键约束"></a>7.3 外键约束</h4><p>InnoDB是目前MySQL中唯一支持外键的内置存储引擎</p>
<h4 id="7-4-在MySQL内部存储代码"><a href="#7-4-在MySQL内部存储代码" class="headerlink" title="7.4 在MySQL内部存储代码"></a>7.4 在MySQL内部存储代码</h4><p>MySQL允许通过触发器、存储过程、函数的形式来存储代码。从MySQL 5.1开始，还可以在定时任务中存放代码，这个定时任务也被称为“事件”。存储过程和存储函数都被统称为“存储程序”。<br>存储过程和存储函数都可以接收参数然后返回值，但是触发器和事件却不行。<br>触发器可以让你在执行INSERT、UPDATE或者DELETE的时候，执行一些特定的操作。<br>事件在一个独立事件调度线程中被初始化，这个线程和处理连接的线程没有任何关系。它不接收任何参数,也没有任何的返回值。可以在MySQL的日志中看到命令的执行日志，还可以在表INFORMATION_SCHEMA.EVENTS中看到各个事件状态，例如这个事件最后一次被执行的时间等。<br>MySQL的命令行客户端会自动过滤注释。一个将注释存储到存储程序中的技巧就是使用版本相关的注释，因为这样的注释可能被MySQL服务器执行</p>
<h4 id="7-5-游标"><a href="#7-5-游标" class="headerlink" title="7.5 游标"></a>7.5 游标</h4><p>MySQL在服务器端提供只读的、单向的游标，而且只能在存储过程或者更底层的客户端API中使用。<br>当你打开一个游标的时候需要执行整个查询</p>
<h4 id="7-6-绑定变量-prepared-statement"><a href="#7-6-绑定变量-prepared-statement" class="headerlink" title="7.6 绑定变量(prepared statement)"></a>7.6 绑定变量(prepared statement)</h4><p>当创建一个绑定变量SQL时，客户端向服务器发送了一个SQL语句的原型。服务器端收到这个SQL语句框架后，解析并存储这个SQL语句的部分执行计划，返回给客户端一个SQL语句处理句柄。以后每次执行这类查询，客户端都指定使用这个句柄。<br>在准备阶段；在第一次执行的时候；在每次SQL语句执行时<br>SET @sql := ‘SELECT actor_id,first_name,last_name FROM sakila.actor WHERE first_name = ? ‘ ;<br>PREPARE stmt_fetch_actor FROM @sql;<br>SET @actor_name := ‘Penelope’;<br>EXECUTE stmt_fetch_actor USING @actor_name;<br>DEALLOCATE PREPARE stmt_fetch_actor;<br>客户端模拟的绑定变量;服务器端的绑定变量;SQL接口的绑定变量</p>
<h4 id="7-7-用户自定义函数"><a href="#7-7-用户自定义函数" class="headerlink" title="7.7 用户自定义函数"></a>7.7 用户自定义函数</h4><p>用户自定义函数（UDF)。<br>UDF必须事先编译好并动态链接到服务器上，这种平台相关性使得UDF在很多方面都很强大。UDF速度非常快,而且可以访问大量操作系统的功能，还可以使用大量库函数。</p>
<h4 id="7-8-插件"><a href="#7-8-插件" class="headerlink" title="7.8 插件"></a>7.8 插件</h4><p>存储过程插件;后台插件;INFORMATION SCHEMA 插件;全文解析插件;审计插件;认证插件</p>
<h4 id="7-9-字符集和校对"><a href="#7-9-字符集和校对" class="headerlink" title="7.9 字符集和校对"></a>7.9 字符集和校对</h4><p>字符集是指一种从二进制编码到某类字符符号的映射<br>“校对’是指一组用于某个字符集的排序规则<br>每一类编码字符都有其对应的字符集和校对规则<br>每种字符集都可能有多种校对规则，并且都有一个默认的校对规则。<br>MySQL的设置可以分为两类:创建对象时的默认值、在服务器和客户端通信时的设置。<br><img    class="lazyload" data-original="https://s2.loli.net/2022/02/22/ZIHowxsMGU8NzcF.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="    style="zoom:50%;" /><span class="image-caption">客户端和服务器的字符集</span><br>SELECT. _utf8 ‘hello world’ COLLATE utf8_bin;<br>诡异的character_set_database设置; LOAD DATA INFILE; SELECT INTO OUTFILE; 嵌入式转义序列<br>可以使用命令SHOW CHARACTERSET和SHOW COLLATION来查看MySQL支持的字符集和校对规则。<br>大小写敏感和二进制校对规则的不同之处在于，二进制校对规则直接使用字符的字节进行比较，而大小写敏感的校对规则在多字节字符集时，有更复杂的比较规则。<br>只有排序查询要求的字符集与服务器数据的字符集相同的时候，才能使用索引进行排序。索引根据数据列的校对规则进行排序。<br>有时候根本不需要使用任何的字符集。通常只有在做大小写无关的比较、排序、字符串操作(例如SUBSTRING()的时候才需要使用字符集。</p>
<h4 id="7-10-全文索引"><a href="#7-10-全文索引" class="headerlink" title="7.10 全文索引"></a>7.10 全文索引</h4><p>全文索引可以支持各种字符内容的搜索(包括CHAR、VARCHAR和TEXT类型)，也支持自然语言搜索和布尔搜索。</p>
<h4 id="7-11-分布式-XA-事务"><a href="#7-11-分布式-XA-事务" class="headerlink" title="7.11 分布式(XA) 事务"></a>7.11 分布式(XA) 事务</h4><p>XA事务中需要有一个事务协调器来保证所有的事务参与者都完成了准备工作(第一阶段)。如果协调器收到所有的参与者都准备好的消息，就会告诉所有的事务可以提交了，这是第二阶段。<br>实际上，在MySQL中有两种XA事务。一方面，MySQL可以参与到外部的分布式事务中;另一方面，还可以通过XA事务来协调存储引擎和二进制日志。<br>MySQL能够作为参与者完成一个外部的分布式事务。<br>XA事务是一种在多个服务器之间同步数据的方法。</p>
<h4 id="7-12-查询缓存"><a href="#7-12-查询缓存" class="headerlink" title="7.12 查询缓存"></a>7.12 查询缓存</h4><p>MySQL判断缓存命中的方法很简单:缓存存放在一个引用表中，通过一个哈希值引用，这个哈希值包括了如下因素，即查询本身、当前要查询的数据库、客户端协议的版本等<br>一些其他可能会影响返回结果的信息。<br>当查询语句中有一些不确定的数据时，则不会被缓存。事实上，如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、mysql库中的系统表，或者任何包含列级别权限的表，都不会被缓存。<br>MySQL用于查询缓存的内存被分成一个个的数据块，数据块是变长的。每一个数据块中，存储了自己的类型、大小和存储的数据本身，还外加指向前一个和后一个数据块的指针。<br>数据块的类型有:存储查询结果、存储查询和数据表的映射、存储查询文本，等等。<br>缓存碎片、内存不足、数据修改都会造成缓存失效。<br>Com_*来查看数据修改的情况(包括Com_ update， Com_ delete，等等)<br>可以通过Qcache_lowmem_prunes来查看有多少次失效是由于内存不足导致的。<br>“命中和写入”的比率，即Qcache_hits和Qcache_inserts的比值。<br>命中带来的性能提升大于缓存失效的消耗，并且查询缓存并没有成为系统的瓶颈。<br>最好的判断查询缓存是否有效的办法还是通过查看某类查询时间消耗是否增大或者减少来判断。Percona<br>query_cache_type; query_cache_size; query_cache_min_res_unit; query_cache_limit；query_cache_wLock_invalidate<br>cache_min_res_unit可以减少由碎片导致的内存空间浪费。设置合适的值可以平衡每个数据块的大小和每次存储结<br>果时内存块申请的次数。调整合适的值其实是在平衡内存<br>浪费和CPU消耗。<br>可以通过内存实际消耗(query_cache_size-Qcache_free_memory)除以Qcache_queries_in_cache计算单个查询的平均缓存大小。<br>参数Qcache_free_blocks 反映了查询缓存中空闲块的多少<br>可以使用命令FLUSH QUERY CACHE完成碎片整理。<br>清空缓存由命令RESET QUERY CACHE 完成。<br><img    class="lazyload" data-original="https://s2.loli.net/2022/02/22/gxfO54nqHpBv6Cw.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">如何分析和配置查询缓存</span><br>查询缓存存储、检索和失效操作都是在MySQL层面完成，InnoDB无法绕过或者延迟这个行为。但InnoDB可以在事务中显式地告诉MySQL何时应该让某个表的查询缓存都失效。<br>InnoDB让所有有加锁操作的事务都不使用任何查询缓存，这个限制其实并不是必须的。<br>库表结构的设计、查询语句、应用程序设计都可能会影响到查询缓存的效率。<br>分区表；视图；外键；存储过程；绑定变量；插件；字符集；全文索引；XA事务；查询缓存</p>

      </section>
      <section class="extra">
        
          <ul class="copyright">
  
    <li><strong>本文作者：</strong>Mengyuan Chen</li>
    <li><strong>本文链接：</strong><a href="http://example.com/2022/02/22/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/%E6%89%93%E9%80%A0%E5%9D%9A%E5%AE%9E%E7%9A%84%E5%9F%BA%E7%A1%80/index.html" title="http:&#x2F;&#x2F;example.com&#x2F;2022&#x2F;02&#x2F;22&#x2F;%E9%AB%98%E6%80%A7%E8%83%BDMySQL&#x2F;%E6%89%93%E9%80%A0%E5%9D%9A%E5%AE%9E%E7%9A%84%E5%9F%BA%E7%A1%80&#x2F;index.html">http:&#x2F;&#x2F;example.com&#x2F;2022&#x2F;02&#x2F;22&#x2F;%E9%AB%98%E6%80%A7%E8%83%BDMySQL&#x2F;%E6%89%93%E9%80%A0%E5%9D%9A%E5%AE%9E%E7%9A%84%E5%9F%BA%E7%A1%80&#x2F;index.html</a></li>
    <li><strong>版权声明：</strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" title="BY-NC-SA" target="_blank" rel="noopener">BY-NC-SA</a> 许可协议，转载请注明出处！</li>
  
</ul>
        
        
          <section class="donate">
  <div id="qrcode-donate">
    <img   class="lazyload" data-original="https://sm.ms/image/Y6TiL7UgNHm2RSl" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" >
  </div>
  <div class="icon">
    <a href="javascript:;" id="alipay"><i class="iconfont iconalipay"></i></a>
    <a href="javascript:;" id="wechat"><i class="iconfont iconwechat-fill"></i></a>
  </div>
</section>
        
        
        
  <nav class="nav">
    <a href="/2022/02/22/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/%E9%85%8D%E7%BD%AE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"><i class="iconfont iconleft"></i>配置应用程序</a>
    <a href="/2022/02/22/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/%E6%A6%82%E8%BF%B0/">概述<i class="iconfont iconright"></i></a>
  </nav>

      </section>
      
    </section>
  </div>
</article></div>
      <div class="col-xl-3">
        
          
  <aside class="toc-wrap">
    <h3 class="toc-title">文章目录：</h3>
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-MySQL%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95"><span class="toc-text">第二章 MySQL基准测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90"><span class="toc-text">第三章 服务器性能剖析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-Schema%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BC%98%E5%8C%96"><span class="toc-text">第4章 Schema与数据类型优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="toc-text">第5章 创建高性能的索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-text">第六章 查询性能优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C%E7%9A%84%E5%9F%BA%E7%A1%80"><span class="toc-text">6.4 查询执行的基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-MySQL%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7"><span class="toc-text">第七章 MySQL高级特性</span></a></li></ol>
  </aside>

        
      </div>
    </div>
  </div>
</main>
  

<footer class="footer">
  <div class="footer-social"><a 
        href="tencent://message/?Menu=yes&uin=2274849184 "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#12B7F5'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconQQ "></i>
      </a><a 
        href="javascript:; "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#09BB07'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconwechat-fill "></i>
      </a><a 
        href="https://www.instagram.com/xxdsh/ "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#DA2E76'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconinstagram "></i>
      </a><a 
        href="https://github.com/xxdsh "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#9f7be1'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  icongithub-fill "></i>
      </a><a 
        href="mailto:mychen@buaa.edu.cn "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color=#FF3B00" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconmail"></i>
      </a></div>
  
    <div class="footer-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Cure The World </p></div>
  
</footer>
  
      <div class="fab fab-plus">
    <i class="iconfont iconplus"></i>
  </div>
  
  
  <div class="fab fab-up">
    <i class="iconfont iconcaret-up"></i>
  </div>
  
  
  
    
<script src="/js/color-mode.js"></script>

  
  
    <div class="search">
  <div class="search-container">
    <div class="search-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <div class="search-input-wrapper">
      <i class="search-input-icon iconfont iconsearch"></i>
      <input class="search-input" type="search" id="search-input" placeholder="Search..." autofocus autocomplete="off"
        autocorrect="off" autocapitalize="off">
    </div>
    <div class="search-output" id="search-output"></div>
  </div>
</div>
  
</body>

<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>



  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script>




  
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script>






  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.qrcode/1.0/jquery.qrcode.min.js"></script>




<script src="/js/utils.js"></script>
<script src="/js/script.js"></script>







  <script>
    (function () {
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      } else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>













</html>